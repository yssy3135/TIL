


# 실행 계획 

### 실행 계획 확인
- MySQL 서버의 실행 계획은 DESC, EXPLAIN 멸령으로 확인
- JSON 이나 TREE, 단순 테이블 형태로 선택이 가능하다.


### 쿼리의 실행 시간 확인
- 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 EXPLAIN ANALYZE
- EXPLAIN ANALYZE 명령은 항상 결과를 TREE 포맷으로 보여줌.


**Tree 포맷의 호출 순서**
- 들여쓰기가 호출 순서를 의미
- 들여쓰기가 같은 레벨에서는 상단에 위차한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행

## 실행 계획 분석
**실행계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요**

![실행계획1.png](image%2F%EC%8B%A4%ED%96%89%20%EA%B3%84%ED%9A%8D%20%ED%99%95%EC%9D%B8%20image%2F%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D1.png)

- 표의 각 라인(레코드)는 쿼리 문장에서 사용된 테이블(서브쿼리로 임시 테이블을 생성한 경우 임시테이블도 포함) 개수만큼 출력
- 실행 순서는 위에서 아래
- 위쪽에 출력된 결과일수록(id 컬럼 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블
- 아래쪽에 출력된 결과일수록(id 컬럼 값이 클수록) 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블에 해당




### id 컬럼
- 하나의 SELECT 문장은 다시 1개 이상의 하위(SUB) SELECT 문장을 포함할 수 있다.
- id 컬럼은 SELECT 쿼리별로 부여되는 식별자 값.
- 실행 계획의 id 컬럼이 테이블의 접근 순서를 의미하지는 않음.


**id 부여 방식**
- 하나의 SELECT 문에서 여러개의 테이블이 조인되는 경우는 같은 id가 부여
- 하나의 SELECT 에 여러개의 SELECT 쿼리로 구성되있으면 각기 다른 id값을 가짐


### select_type 컬럼
- 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼.

### select_type 컬럼에 표시될 수 있는 값

**SIMPLE**
- UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
- 쿼리 문장이 아무리 복잡해도 실행 계획에서 select_type이 SIMPLE인 쿼리는 단 하나만 존재
- 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 SIMPLE

**PRIMARY**
- UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer) 에 있는 단위 쿼리는 select_type이 PRIMARY로 표시
- SIMPLE 과 마찬가지 select_type이 PRIMARY인 단위 SELECT 쿼리는 단 하나만 존재
- 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시

**UNION**
- SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type은 UNION으로 표시
- UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION 되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)로 사용, DERIVED select_type으로 표시됨.


**DEPENDENT UNION**
- UNION select_type과 같이 UNION이나 UNION ALL로 집합 결합하는 쿼리에서 표시
- DEPENDENT는 UNION인 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것.

```
mysal> EXPLAIN
		SELECT *
		FROM employees e1 WHERE e1. emp_no IN (
			SELECT e2.emp_no FROM employees e2 WHERE e2. first_name='Matt'
			UNION
			SELECT e3.emp_no FROM employees e3 WHERE e3. last_name= 'Matt'
		);
```

위 예를 들면
- UNION 이 사용된 SELECT 쿼리의 WHERE조건에 "e2.emp_no = e1.emp_no" 와 "e3.emp_no = e1.emp_no" 라는 조건이 자동으로 추가되어 실행
- 외부에 정의된 employees 테이블의 emp_no 컬럼이 서브쿼리에 사용되기 때문에 DEPENDENT UNION이 select_type에 표시되는 것.


**UNION RESULT**
- UNION 결과를 담아두는 테이블을 의미
- MySQL8.0 이전 버전에서는 UNION ALL 이나 UNION(또는 UNION DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성,
  이후 8.0 이후 버전에서는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선됨.
- UNION RESULT를 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id는 부여되지 않음.

![실행계획2.png](image%2F%EC%8B%A4%ED%96%89%20%EA%B3%84%ED%9A%8D%20%ED%99%95%EC%9D%B8%20image%2F%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D2.png)

UNION RESULT 라인의 table 컬럼은 <union1,2> 라고 표시가 되어있는데
id 값이 1인 조회 결과와 id 값이 2인 죄회 결과를 union 했다는 것을 의미.

![실행계획3.png](image%2F%EC%8B%A4%ED%96%89%20%EA%B3%84%ED%9A%8D%20%ED%99%95%EC%9D%B8%20image%2F%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D3.png)

위 쿼리에서 UNION DISTINCT 대신 UNION ALL 을 사용할 경우 임시테이블을 사용하지 않기 때문에  "UNION RESULT" 라인이 필요치 않게 된다.








