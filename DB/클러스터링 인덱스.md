

## 클러스터링 인덱스

****************************************클러스터링이란?****************************************

여러개를 하나로 묶는다는 의미

- MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키 기준)들 끼리 묶어서 저장하는 형태로 구현
- MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원하지 않음.

### 클러스터링 인덱스

- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장한다는 것.
- 중요한 것은 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다는것.
    - 이것은 프라머리 키 값이 변경되면 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미
- 프라이머리 키 값으로 클러스터링 된 테이블은 프라이머리 키 값에 대한 의존도가 상당히 커 신중히 프라이머리 키를 결정해야 한다.


**클러스터링 인덱스와 클러스터링 테이블은 동의어?**
클러스터링 인덱스는 프라이머리 키 값에 의해 레코드의 저장위치가 결정되므로 인덱스 알고리즘 이라기 보다 테이블 레코드의 저장 방식


일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르다, 하지만 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다


> B-Tree 인덱스도 키 값으로 이미 정렬
> 어떻게 보면 인덱스의 키 값으로 클러스터링 된 것으로 생각할 수 있다.
> 하지만 테이블 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 '클러스터링 인덱스' , '클러스터링 테이블 ' 이라고 한다.


**클러스터링 인덱스의 구조**

![Pasted image 20230919225031.png](image%2F%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%20image%2FPasted%20image%2020230919225031.png)

- B-Tree와 비슷 한 구조를 하고있다.
- 세컨더리 인덱스를 위한 B-Tree의 리프노드와 달리 클러스터링 인덱스의 리프 노드에 모든 컬럼이 같이 저장되어 있다.
- 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리


**프라이머리 키 가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성될까?**
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택


**적절한 클러스터링 키가 없을때 어떻게 내부적으로 컬럼을 추가할까?**
- InnoDB 스토리지 엔진이 내부적으로 레코드의 일련변호 컬럼 생성
- 자동으로 추가된 프라이머리 키(일련번호 컬럼)은 사용자에게 노출되지 않고 쿼리에 명시적으로 사용할 수 없다.
- 프라이머리 키나 유니크 인덱스가 전혀 없는 InnoDB 테이블에서는 아무 의미 없는 숫자 값으로 클러스터링
- InnoDB 테이블에서 클러스터링 키는 테이블당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하면 명시적으로 생성하는 것이 좋다.

### 세컨더리 인덱스에 미치는 영향

- InnoDB에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 클러스터링 키 값이 변경될 때마다 레코드의 주소가 변경되고 그 때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 한다.
- 위 같은 오버헤드를 제거하기 이해 InnoDB 테이블(클러스터링 테이블) 은 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아닌 프라이머리 키 값을 저장하도록 구현돼 있음.



### 클러스터링 인덱스의 장점과 단점


**장점**
- 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름( 프라이머리 키 범위 검색하는 경우 매우 빠름)
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음 -> 커버링 인덱스.

**단점**
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값이 클 경우 전체적으로 인덱스 크기가 커짐
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT 하는 작업이 필요하기 때문에 성능이 느림


**대부분 클러스터링 인덱스의 장점은 빠른 읽기(SELECT)! ,단점은 느린 쓰기 (INSERT , UPDATE, DELETE) 인 것을 알 수 있다.**


### 클러스터링 테이블 사용시 주의사항

- 클러스터링 테이블은 모든 세컨더리 인덱스가 프라이머리 키 (클러스터링 키)값 을 포함하기 대문에
  프라이머리 키의 크가기 커지만 세컨더리 인덱스도 자동으로 크기가 커진다 때문에 InnoDB 프라이머리 키는 신중하게 선택해ㅑㅇ 한다.

### 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 컬럼으로 생성(가능한 경우)

- InnoDB의 프라이머리 키는 클러스터링 키로 사용되며 프라이머리 키 값에 따라 레코드의 위치가 결정
- 프라이머리 키로 검색하는 경우( 범위로 많은 레코드를 검색하는 경우) 클러스터링 되지 않은 테이블에 비해 매우 빠르게 처리된다.
- 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 프라이머리 키로 설정하는 것이 좋다.


### 프라이머리 키는 반드시 명시할 것
- AUTO_INCREMENT 컬럼을 이용해서라도 프라이머리 키는 생성하는 것을 권장.
- InnoDB 테이블에 프라이머리 키를 정의하지 않은 경우와 AUTO_INCREMENT 컮럼을 생성하고 프라이머리 키로 설정하는 것은 결국 동일하다.
- 그렇다면 사용자가 사용할 수 있는 값(AUTO_INCREMENT)값 을 프라이머리 키로 설정하는 것이 좋을 것.
- ROW 기반 본제나 InnoDB Cluster에서는 머든 테이블이 프라이머리 키를 가져야만 하는 정상적인 복제 성능을 보장하기도 하므로 프라이머리 키는 꼭 생성하는 것이 좋다.


### AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우

- 여러 개 컬럼이 복합으로 프라이머리 키를 구성하게 되면 크기가 길어질 수 있다.
- 프라이머리 키의 크기기가 길어도 세컨더리인덱스가 필요하지 않다면 그대로 사용하는 것이 좋다.
- 세컨더리 인덱스도 필요하고 프라이머리 키도 길다면 AUTO_INCREMENT 컬럼을 추가하고 이를 프라이머리 키로 설정해라.

**인조 식별자**
- 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키



## 유니크 인덱스

- 인덱스라기보다 제약조건
- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
    - 유니크 인덱스에서도 NULL은 저장될 수 있는데 특정 값이 아니기 때문에 2개 이상 저장될 수 있다.
- MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여됨.

**스토리지 엔진 간 차이**
- MyISAM, MEMORY(NON-CLUSTERING) 프라이머리키는 NULL이 허용되지 않는 유니크 인덱스 와 같다.
- InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하기 때문에 유니크 인덱스와는 근복적으로 다름


### 인덱스 읽기
- 유니크 인덱스가 빠르다고 생각하지만 이것은 사실이 아님.
- 유니크 인덱스는 1건만 읽으면 되지만 유니크하지 않은 세컨더리 인덱스에서 레코드를 한 건 더 읽어야 하므로 느리다고 하지만 사실이 아님.
- 세컨더리 인덱스에서 한 번 더 해야하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼값을 비교하는 작업 -> 성능상 영향이 거의 없다.
- 유니크하지 않은 세컨더리 인덱스는 **중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느리거지 인덱스 자체의 특성은 아님**


### 인덱스 쓰기

**유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리다!**

- 유니크 인덱스에서는 중복 값을 검사하는 과정이 한단계 더 필요
- MySQL에서는 읽기 를 할때 읽기 잠금을 사용하고 쓰기를 할 때 쓰기 잠금을 사용하는데 이과정에서 데드락이 빈번하게 발생
- InnoDB 엔진에서 인덱스 키의 저장을 버퍼링하기위해 체인지 버퍼가 사용
    - 따라서 상당히 빨리 변경작업이 처리되지만 유니크 인덱스는 반드시 중복 체크를 해야하기때문에 작업 자체를 버퍼링 하지 못함 ->  **때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경이 느리게 처리됨**



### 유니크 인덱스 사용 시 주의사항


**불필요하게 유니크 인덱스를 생성하지 않는 것이 좋다.**

하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요는 없다.
- MySQL의 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.

동일한 컬럼에대해 프라이머리 키와 유니크를 동일하게 생성하는 것도 불필요한 중복이다.

**유일성이 꼭 보장되어야 하는 컬럼에 대해서는 유니크 인덱스를 생성하되 꼭 필요하지 않다면 세컨더리 인덱스를 생성하는 방법도 고려해보자**
