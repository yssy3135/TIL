
## ORDER BY 처리(Using filesort)

|              | 장점                                                                                                                                                       | 단점                                                                                                                                                                                               |
|:------------ |:---------------------------------------------------------------------------------------------------------------------------------------------------------- |:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 인덱스 이용  | INSERT,UPDATE,DELETE쿼리가 실행될 때 이미 인덱스가 정렬, 순서대로 읽기만 하면 됨                                                                           | INSERT,UPDATE,DELETE 작업시 부가적인 인덱스 추가,삭제 작업이 필요하므로 느리다. 인덱스때문에 디스크 공간이 더 많이 필요, 인덱스의 개수가 늘어날수록 InnoDB의 버퍼풀을 위한 메모리가 많이 필요하다. |
| Filesort이용 | 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때 의 단점이 장점으로 바뀜, 정렬해야 할 코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                                                                                                                                                                                                   |



**모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다!**
- 정렬 기준이 너무 많아 요건별 모두 인덱스 생성이 불가능
- GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 겨로가를 다시 정렬해야 하는 경우
- 램덤하게 결과 레코드를 가져와야 하는 경우


> 인덱스를 이용하지 않고 정렬을 수행했는지 여부는 실행계획의 Extra 칼럼에 Using filesort 메서지가 표시되는지 여부로 판단할 수 있다.




### 소트 버퍼

**소트 버퍼란?**
- MySQL은 정렬을 하기위해 메모리를 할당받아 사용, 이 메모리공간을 소트 버퍼라 한다.
- 정렬이 필요한 경우에만 할당
- 버퍼 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가, 하지만 sort_buffer_size라는 시스템 변수로 설정 할 수 있다.
- 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 반납된다.


**정렬이 왜 문제가 될까?**
- 레코드가 소량 이어서 메모리에 할당된 소트버퍼만으로 정렬할 수 있다면 아주 빠르게 정렬될 것.
- 레코드의 건 수가 소트버퍼에 할당된 공간보다 크다면?
  **멀티 머지**
    - 정렬해야할 레코드를 여러 조각으로 나누어서 처리
        - 메모리의 소트 버퍼에서 정렬을 수행하고 결과를 디스크에 임시저장
        - 다음 레코드 가져와 다시 정렬하고 디스크에 임시저장
    - 버퍼 크기만큼 정렬된 레코드들을 다시 병합하면서 정렬 수행.
    - 수행된 멀티 머지 횟수는 Sort_merge_passes 라는 상태 변수에 누적 집계됨.
- 멀티 머지 작업을 진행하면서 디스크의 I/O 유발 하여 성능 저하

**소트 버퍼의 크기**
- sort_buffer_size 크기가 커질수록 빨라지지 않는다.
- 리눅스 계열 운영체제에서는 sort_buffer_size를 너무 크게 사용할 경우 성능이 훨씬 떨어질 수 있다.
- 소트 버퍼 크기는 56KB 에서 1M 미만이 적절
- 정렬을 위해 사용하는 소트 버퍼는 **세션메모리 영역에 해당**
    - 세션메모리영역은 여러 클라이언트가 공유해서 사용하는 영역이 아님.
    - 커넥션이 많을수록 **소트 버퍼로 소비되는 공간이 커져 운영체제는 메모리 부족 현상을 일으킬 수 있음.**



### 정렬 알고리즘
레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 "싱글 패스(Single-pass)" 와 "투패스(Two-pass)" 2가지 정렬 모드로 나눌 수 있다.


**MySQL 서버의 3가지 정렬 방법**
- <sort_key, rowid> : 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬
- <sort_key, additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정 사이즈로 저장
- <sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들을 가변 사이즈로 저장
    - MySQL5.7 버전부터 도입, 메모리의 효율적인 공간사용을 위함.



### 싱글 패스 정렬 방식
소트 버퍼에 **정렬 기준 컬럼**을 포함해 **SELECT 대상이 되는 컬럼 전부**를 담아서 정렬을 수행하는 정렬 방법


### 투 패스 정렬방식
**정렬 대상 컬럼**과 **프라이머리 키 값**만 소트 버퍼에 담아서 정렬을 수행하고 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식


- 싱글 패스 도입 이전부터 사용
- 특정 조건에서는 여전히 투 패스를 사용하는 경우도 있다.


**싱글 패스와 투 패스 비교**
- 투 패스 방식은 테이블을 두번 읽어야 하기 때문에 불합리적.
- 하지만 싱글 패스 방식은 더 많은 소트 버퍼의 공간이 필요
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식 사용
- 싱글 패스 방식은 레코드의 크기나 건수가 작은 경우 빠름.
- 투패스 방식은 크기나 건수가 상당히 많은 경우 효율적.


**MySQL에서 투 패스를 사용하는 경우**
- 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클때
- BLOB 이나 TEXT 타입의 컬럼이 SELECT대상에 포함할 때


### 정렬 처리 방법

**Order By 처리 방법 3가지**
아래로 갈수록 처리 속도는 떨어짐.

| 정렬 처리 방법                                 | 실행 계획의 Extra 컬럼 내용       |
|:---------------------------------------------- |:--------------------------------- |
| 인덱스를 사용한 정렬                           | 별도 표기 없음                    |
| 조인에서 드라이빙 테이블만 정렬                | "Using filesort" 메시지 표시      |
| 조인에서 조인 결과를 임시 테이블로 저장후 정렬 | "Using temporary; Using filesort" 메시지 표시 | 


- 인덱스를 사용할 수 있다면  "filesort" 없이 인덱스를 순서대로 읽어서 반환
- 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)


**옵티마이저는 정렬 대상 레코드를 최소화 하기위해 2가지 방법을 사용한다.**
조인을 하면 레코드의 수가 배수로 불어나기 때문에 드라이빙 테이블만 정렬한 후 조인하는 것이 효율 적
- 조인의 드라이빙 테이블만 정렬한 다음 조인 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행


> 드라이빙 테이블 이란?
> JOIN 시 먼저 액세스 되어서 ACCESS PATH를 주도하는 테이블
> 나중에 액세스 되는 테이블을 드리븐 테이블(DRIVEN TABLE, INNER TABLE)이라고 함.


인덱스를 이용한 정렬

**인덱스를 이용한 정렬을 하기 위한 조건**
- ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인되었다면 드라이빙 테이블)에 속하고
- ORDER BY에 순서대로 생성된 인덱스가 있어야 한다.
- WHERE 절에 첫번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 같은 ORDER BY는 같은 인덱스를 사용할 수 있어야 함.
- B-Tree 계열의 인덱스가 아닌 인덱스는 인덱스를 이용한 정렬을 할 수 없다. (R-Tree도 사용할 수 없다.)
- 여러 테이블이 조인되는 경우 네스티드-루프(Nested-loop) 방식의 조인에서만 이 방식을 사용 할 수 있다.


**인덱스를 사용한 정렬이 가능한 이유**
- 인덱스를 이용한 정렬에서는 인덱스가 정렬되어 있기 때문에 MySQL서버에서 따로 정렬 작업을 하지 않음.
    - B-Tree가 인덱스 키값으로 정렬되어있기 때문
- 조인이 네스티드-루프 방식으로 실행되기 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않음
- 조인이 사용된 쿼리의 실행계획에 조인 버퍼(Join buffer)가 사용되면 순서가 흐트러질 수 있기 때문에 주의 해야 함.


### 조인의 드라이빙 테이블만 정렬
- 일반적으로 조인이 수행되면 레코드 건수가 몇 배로 불어나고 레코드 하나하나 크기도 늘어난다.
- 그래서 조인을 실행하기 전에 첫 번째 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선택이 될 것.
- 이 방법으로 정렬이 처리되게 하려면 **첫번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 Order By를 작성해야 한다.**



### 임시 테이블을 이용한 정렬

**임시 테이블은 언제 필요할까?**
- 쿼리가 여러 테이블을 조인하지 않고 하나의 테이블로부터 SELECT 해서 정렬하는 경우라면 임시 테이블 필요하지 않음
- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블 필요
- 항상 조인의 결과를 임시 테이블에 저장해야 하고 다시 정렬하는 과정을 거침
- 정렬의 3가지 방법 가운데 정렬해야할 레코드가 가장 많기 때문에 가장 느린 정렬 방법이다.

쿼리 실행 계힉의 Extra 컬럼에 "Using temporary: Using filesort"라는 코멘트로 표시된다.


### 정렬 처리 방법의 성능 비교

쿼리가 처리되는 방법 "스트리밍 처리", "버퍼링 처리"


### 스트리밍 방식
- 서버쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 클라이언트로 전송해주는 방식
- 쿼리를 요청하고 곧바로 첫 번째 레코드를 전달받음, 가장 마지막 레코드는 언제 받을지 알 지 못함.

- 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터 가공 작업을 진행 할 수 있다.
- 웹 서비스 같은 OLTP 환경에서 는 첫 번째 레코드를 전달받게 되기까지의 응답 시간이 중요
- **스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답시간을 보장**


**스트리밍 방식으로 처리되는 쿼리에사 LIMIT 처럼 결과 건수를 제한하는 조건들은  실해 시간을 상당히 줄여준다.**
- 풀 테이블 스캔의 결과가 아무런 버퍼링 처리나 필터링 과정 없이 바로 클라이언트로 스트리밍 되기 때문
- LIMIT 조건을 추가하면 전체적으로 가져오는 레코드 건수가 줄어 마지막 레코드를 가져오기까지 시간이 상당히 단축됨.


### 버퍼링 방식
- Order By나 Group By 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 함.
- Where 절에 일치하는 레코드를 모두 가져온 후에 정렬하거나 그루핑해서 차례대로 보내야 하기 때문
- MySQL 서버에서는 레코드를 검색하고 정렬하는 동안 아무런 작업을 할 수 없어 응답 속도가 느려진다.
    - 이 방식을 스트리밍의 반대 표현으로 버퍼링 이라고 표현
- LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음.


> Order By 3가지 처리 방법 가운데 인덱스를 활용한 정렬방식만 스트리밍 형태 처리
> 나머지는 모두 버퍼링 후에 처리됨.
