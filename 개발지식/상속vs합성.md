상속과 합성 모두 객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법이다.

### 상속

- 서브클래싱, 즉 부모 클래스에서 상속받아 클래스의 구현을 정의하는 방식
- 서브클래싱에 의한 재사용을 화이트박스 재사용(white-box reuse)라고 한다.
    - ‘화이트박스’는 내부를 볼 수 있다는 의미에서 나온 말로, 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트 박스인 셈

### 상속의 장단점

장점

- 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다.
- 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 있는데, 서브 클래스는 모든 연산이 아닌 일부만 재정의할 수도 있다.

단점

- 상속은 부모 클래스의 구현이 서브클래스에 드러나는 것이기 때문에 상속은 캡슐화를 파괴한다고 보는 시각도 있다.
- 서브클래스는 부모 클래스의 구현에 종속될 수밖에 없으므로, 부모 클래스 구현에 변경이 생기면 서브클래스도 변경 될 수밖에 없다.

구현의 종속성이 걸림돌로 작용하면서, 서브클래스를 재사용하려고 할 때 문제가 발생한다.
삭송한 구현이 새로운 문제에 맞지 않을 때, 부모 클래스를 재작성해야 하거나 다른 것으로 대체하는 일이 생기게 된다.

이런 종속성은 유연성과 재사용성을 떨어뜨린다.

→ 이를 해결하는 방법은 추상클래스에서만 상속 받는 것이다. 추상 클래스에는 구현이 거의 없거나 아예 없기 때문이다.

이미 추상 클래스를 상속했다는 것은 구현이 아닌 인터페이스를 상속한 것이므로 구현 자체는 서브클래스가 정의한다.

구현이 변경되면 서브클래스만 변경하면 되고 상위 추상클래스는 고려할 필요가 없다.

### 합성

- 클래스 상속에 대한 대안으로 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것
    - 즉, 객체 또는 데이터 유형을 더 복잡한 유형으로 결합하는 방법
- 객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 한다.
- 이런 스타일의 재사용을 블랙박스 재사용(block-box reuse)라고 한다.
    - 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문.

합성은 객체가 다른 객체에 대한 참조자를 얻는 방식

런타임에 동적으로 정의

합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에 인터페이스 정의에 더 많은 주의를 기울여야 한다.

객체는 인터페이스만 접근하므로 캡슐화를 유지할 수 있다.

동일한 타입을 갖는다면 다른 객체로 런타임에 대체가 가능하다.

객체는 인터페이스에 맞춰 구현되므로 구현 사이의 종속성은 확실히 줄어든다.

**클래스보다 합성은 더 선호하는 이유?**

각 클래스의 캡슐화를 유지할 수 있고.(인터페이스만 바라보기 때문)

클래스의 한 가지 작업에 집중할 수 있기 때문이다.

> 재사용을 위해 새로운 구성요소를 생성할 필요 없이 필요한 기존의 구성요소를 조립해서 모든 새로운 기능을 얻어올 수 있다.
그러나 가능한 구성요소의 집합이 실제로 사용할 수 있을 만큼 충분하지 않기 때문에, 기존 구성요소의 조합을 통합 재사용만으로 목적을 달성할 수 있는 경우는 드물다.
상속에 의한 재사용은 기존 클래스들을 조합해서 새로운 구성요소를 쉽게 만들 수 있도록 해 준다.
그러므로 상속과 객체 합성은 적절히 조합되어야만 완벽히 재사용이 가능하다.
>