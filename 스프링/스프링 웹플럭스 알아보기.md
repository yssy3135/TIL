# WebFlux란 뭐지?

- 리액티브 스택 웹 프레임워크
- 5.0 버전에 추가됨
- 완전하게 논블로킹으로 동작
- Reactive Streams back pressure지원
- Netty, Undertow, 서블릿 3.1+ 컨테이너 서버에서 실행

**논블로킹이란?**

**back pressure란?**

- 동기식 명령형(imperative) 코드에서 블로킹 호출은  호출자를 강제로 기다리게 하는 일종의 back pressure
- 논블로킹 코드에서 프로듀서 속도가 컨슈머 속도를 압도하지 않도록 이벤트 속도를 제어

**리액티브 스트림이란?**

- back pressure를 통한 비동기 컴포넌트 간의 상호작용을 정의한 간단한 스펙
- 리액티브 스트림을 쓰는 주 목적은 subscriber가 publisher의 데이터 생산 속도를 제어하는 것.

**publisher 속도를 늦출 수 없으면 어떻게 할까?**

- 리액티브 스트림의 목적은 메커니즘과 경계를 확립하는 것.
- publisher가 속도를 늦출 수 없다면 버퍼에 담을지, 데이터를 날릴지, 실패로 처리할지 걸정해야함

WebFlux는 왜 만들어졌을까?

- 적은 쓰레드로 동시 처리를 제어하고 적은 하드웨어 리소스로 확장하기 위해 논블로킹 웹 스택이 필요
- 이전에 서블릿3.1은 논블로킹 I/O를 위한 API를 제공했음 하지만 서블릿으로 논블로킹을 구현하려면 다른 동기처리(Filter, Servlet) 블로킹 방식(getParameter, getpart)를 사용하는 API를 사용하기 어렵다.
  때문에 어떤 논블로킹과고 잘 동작하는 새 공통 API를 만들게 됨

### Reactor

- 스프링 웹플럭스가 선택한 리액티브 라이브러리.
- Mono, Flux API 타입을 제공
- Mono : 0~1개의 데이터 시퀀스
- Flux : 0~N개의 데이터 시퀀스
- 모든 연산자는 논블로킹과 back pressure를 지원

### 두가지 프로그래밍 모델 지원

- Annotated Controllers
    - 스프링 MVC와 동일
    - MVC, WebFlux 모두 리액티브(Reactor, RxJava) 리턴 타입을 지원
    - WebFlux에서는 @RequestBody로 리액티브 인자를 받을 수 있다.

- Functional Endpoints
    - 경량화된 람다 기반 함수형 프로그래밍 모델
    - Annotated Controllers 와 차이는 어노테이션으로 의도를 선언해서 콜백 받기보다는 요청을 어플리ㅔ이션이 처음부터 끝까지 다 제어한다는 것.

### 스프링 MVC냐 WebFlux냐?

![웹플럭스1.png](image%2F%EC%9B%B9%ED%94%8C%EB%9F%AD%EC%8A%A41.png)

- 이미 잘 동작하고 있는 스프링 MVC 어플리케이션이 있다면 변경할 필요 없다.
- 스프링 웹플럭스는 다른웹 스택과 같은 실행 환경을 제공하면서도, 다양한 서버(Netty, Tomcat, Jetty, Undertow, 서블릿3.1+ 컨테이너)와
  여러 리액티브 라이브러리(리액터, RxJava등)을 지원하며,
  두가지 프로그래밍 모델(어노테이션을 선언한 컨트롤러와 훔수형 웹 엔드포인트) 를 사용할 수 있다.
- 자바8 람다나 코틀린으로 개발할 수 있는 경량의 함수형 웹 프레임워크를 찾는다면
  스프링 웹플럭스의 함수형 웹 엔드포인트를 사용하면 된다.
  로직을 투명하게 제어할 수 있기 때문에 요구사항이 덜 복잡한 소규모 어플리케이션이나 마이크로서비스에서도 좋은 선택이 될 것.
- 마이크로 아키텍처 에서는 스프링 MVC로 만든 어플리케이션과, 스프링 웹플럭스 컨트롤러나 함수형 엔드포인트를 사용한 어플리케이션을 조합할 수 있다.
- 블로킹 방식의 영속성 API(JPA, JDBC)나 네트워크 API를 사용하고 있다면 스프링 MVC가 최도한 아키텍처를 통일 할 수 있으므로 가장 좋은 선택.
- 외부 서비스를 호출한다면 리액티브 WebClient를 사용해볼것.
  서비스 호출에 지연이 있거나 여러 서비스가 엮여 있는 API라면 효과가 좋을 것.
- 팀 규모가 크다면 논블로킹, 선언적 프로그래밍은 러닝커브가 높다는 점도 고려해야 할 것.

### Servers

스프링 웹 플럭스는 톰캣, Jetty, 서블릿 3.1+ 컨테이너에서도, 서블릿 기반이 아닌 Netty나 Undertow에서도 잘 동작한다.

저수준 공통 API로 서버를 추상화하기 때문에 모든 서비스에 고수준 프로그래밍 모델을 적용할 수 있다.

- 서버 기동이나 중단을 위한 내장 기능을 없음
- 기본으로 Netty 사용
    - 논블로킹에 많이 사용하기도 하고, 클라이언트와 서버가 리소스를 공유할 수 있어서.
- 톰캣과 Jetty는 스프링 MVC, 웹플럭스 모두 사용 가능 하지만 동작 방식이 다름
    - 스프링 MVC는 서블릿의 블로킹I/O 사용 어플리케이션에서 필요하면 서블릿 API를 직접 사용할 수 있다.
    - 스프링 웹 플럭스는 서블릭 3.1 논블로킹 I/O로 동작하며 서블릿 API는 저수준 어댑터에서 사용하기 때문에 노출돼 있지 않음

### Concurrency Model

스프링 MVC와 웹플럭스 둘다 annotated controller를 사용하는 점은 동일 동시성 모델과 블로킹/쓰레드 기본 전략이 다름

**스프링 MVC**

- 어플리케이션이 처리 중인 쓰레드가 잠시 중단될 수 있음(외부 서비스)
- 서블릿 컨테이너는 이 블로킹을 대비 큰 쓰레드 풀로 요청을 처리

**스프링 웹 플럭스**

- 실행중인 쓰레드가 중단되지 않는다는 전제가 있음
- 논블로킹 서버는 작은 쓰레드 풀(이벤트 루프 워커)를 고정해놓고 요청을 처리

**Invoking a Blocking API**

- 블로킹 라이브러리를 사용해야 한다면 어떻게 해야할까?
- 리액터, RxJava 모두 다른 쓰레드로 요청을 처리해주는 publishOn오퍼레이터를 지원
- 하지만 블로킹API 자체가 동시성 모델에 적합하지 않다.

**mutable state**

- 리액터와 RxJava 로직은 연산자로 표현
- 연산자를 사용하면 런타임에 분리된 환경에서 리액티브 파이프라인을 만들고 각 파이프라인에서 데이터를 순차적으로 처리
- 파이프라인 안에 있는 코드는 절대 동시에 실행되지 않음 → 더 이상 상태 공유(mutable state)를 신경 쓰지 않아도 된다.

**Threading Model**

스프링 웹플럭스를 사용하는 어플리케이션은 어떤 쓰레드를 얼마나 실행할까?

- 최소한의 웹 플럭스 서버를 띄우면 서버는 쓰레드 한개로 운영하고 소량의 쓰레드로 요청을 처리할 수 있음(보통 CPU 코어수)
- 서블릿 컨테이너는 서블릿 블로킹I/O와 논블로킹I/O를 모두 지원하기 때문에 더 많은 쓰레드를 실행

- 리액티브 WebClient는 이벤트루프를 사용 → 적은 쓰레드를 고정해 두고 쓴다.
- 클라이언트와 서버에서 모두 리액터 Netty를 사용하면 디폴트로 이벤트 루프 리소스를 공유

- 리액터와 RxJava는 스케줄러라는 추상화된 쓰레드 풀 전략을 제공
- 스케줄러라는 이름을 보면 동시 처리 전략을 알 수 있음
    - 제한된 쓰레드로 CPU 연산이 많은 처리를 할 때는 parallel 여러 쓰레드로 I/O가 많은 처리를 할 때는 “elastic” 이다.

**Configuring**

서버의 쓰레드 모델을 바꾸고 싶다면 각 서비에 맞는 설정 API를 참고하거나, 아니면 스프링 부트를 써서 각 서버에 맞는 스프링 부트 옵션을 설정하면 된다.

### Reactive Core

**서버쪽 요청은 저수준과 고수준으로 나눠서 처리**

- HttpHandler
    - 논블로킹 I/O와 리액티브 스트림 back pressure로 HTTP 요청을 처리
    - Netty, Undertow, 톰캣, Jetty,서블릿3.1+ 컨테이너 어댑터와 함께 사용
- WebHandler API
    - 약간 더 고수준 어노테이션을 선언한 컨트롤러나 함수형 엔드포인트같이 구체적ㅇ니 프로그래밍 모델로 작성하는 범용 웹 API
- 클라이언트사이드에서 기본적으로 ClientHttpConnector가 논블로킹I/O와 리액티브 스트림 back pressure로 HTTP 요청을 처리, Reactor Netty, 리액티브 Jetty HttpClient 어댑터와 함께 사용하며, 어플리케이션에서 사용하는 고수준 WebClient는 이를 기반으로 동작
- 클라이언트와 서버 사이드 모두, 코덱으로 Http요청과 응답 컨텐츠를 직렬화/역직렬화