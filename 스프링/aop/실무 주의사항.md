Z### 프록시와 내부 호출

스프링은 프록시 방식의 AOP를 사용한다

AOP를 적용하려면 항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다.

이렇게 해야 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.

프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP가 적용되지 않고, 어드바이스도 호출되지 않는다.

**대상 객체 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.**

******************************************프록시 방식의 AOP 한계******************************************

스프링은  프록시 방식의 AOP를 사용

프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.

### 대안 1 - 자기 자신 주입

본인을 생성하면서 주입해야 하기 때문에 순환 사이클이 만들어진다.

수정자 주입은 스프링이 생성된 이후에 주입할 수 있기 때문에 오류가 발생하지 않는다.

스프링 2.6부터 순환 참조를 기본적으로 금지하도록 정책이 변경되었다.

이 문제를 해결하려면 application.properties에 spring.main.allow-circular-references=true 코드를 추가해야 한다.

### 대안2 - 지연 조회

- 생성자 주입이 실패하는 이유는 자기 자신을 생성하면서 주입해야 하기 때문이다.
- 이경우 수정자 주입을 사용하거나, 지연조회를 사용한다.
- 스프링 빈을 지연해서 조회하기 위해 ObjectProvider(Provider), ApplicationContext를 사용하면 된다.

ApplicaitonContenxt는 너무 많은 기능을 제공하기 때문에 ObjectProvider를 통해 객체를 스프링 컨테이너에서 조회하는 것을 스프링 빈 생성 시점이 아니라 실제 객체를 사용하는 시점으로 지연할 수 있다.

### 대안3 - 구조 변경

가장 나은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다.

실제 이 방법을 가장 권장한다.

> AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용,
인터페이스에 메서드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.
또한 public 메서드에만 적용한다
private 메서드 처럼 작은 다누이에는 AOP를 적용하지 않는다.
>

### 프록시 기술 한계

**JDK 동적 프록시를 사용하면서 의존관계 주입을 할 때 발생하는 문제점**

**구현 클래스타입에 주입할 경우 타입 캐스팅 에러가 발생한다 왜일까?**

JDK 동적프록시는 인터페이스 기반으로 프록시를 생성하기 때문에

구현 클래스와 프록시는 같은 인터페이스를 사용하 전혀 관계없는 객체이다.

**CGLIB를 사용할 경우에는 타입 캐스팅 에러가 발생하지 않는다.**

CGLIB 동적 프록시는 구현 클래스기반으로 프록시를 생성한다.

때문에 구체 클래스를 지정해도 타입 클래스 에러가 발생하지 않는다

또한 구체 클래스는 물론이고 인터페이스로도 캐스팅이 가능하다.

CGLIB를 사용하는 것이 JDK 동적 프록시를 사용하는 방법보다 좋아보인다

**CGLIB 한계**

스프링에서 CGLIB는 구체 클래스를 상속 받아서 AOP 프록시를 생성할 때 사용한다.

CGLIB는 구체 클래스를 상속 받기 때문에 발생하는 문제들이 있다.

**CGLIB 구체 클래스 기반 프록시 문제점**

- 대상 클래스에 기본 생성자 필수

  자바에서 상속을 받으면 자식 클래스의 생성자를 호출할때 부모 클래스의 생성자도 호출해야 한다.

- 생성자 2번 호출 문제
    1. 실제 taget 객체를 생성할 때
    2. 프록시 객체를 생성할때 부모 클래스의 생성자 호출
- final 키워드 클래스, 메서드 사용 불가

  final 키워드가 클래스에 있으면 상속이 불가능하고, 메서드에 있으면 오버라이딩이 불가능 하다.

  CGLIB는 상속을 기반으로 하기 때문에 두 경우 프록시가 생성되지 않거나 정상 동작하지 않는다.


### 스프링의 해결책

- 스프링 3.2, CGLIB를 스프링 내부에 함께 패키징
- CGLIB 기본 생성자 필수 문제 해결

  스프링 4.0부터 objenesis라는 특별한 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하다.

- 스프링 부트 2.0 CGLIB 기본 사용

  구체 클래스 타입으로 의존관계를 주입하는 문제를 해결

  기본적으로 proxyTargetClass=true로 설정해서 사용

  따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체클래스 기반으로 프록시를 생성