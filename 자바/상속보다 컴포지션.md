
### 상속의 특징
- 상위 클래스와 하위 클래스를 모두 같은 패키지 안에서라면 안전한 방법
- 확장할 목적으로 설계되었고 문서화도 잘 되었다면 안정하다.
- 구체 패키지를 넘어 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.


### 상속은 캡슐화를 깨뜨린다.
- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 릴리스마다 상위 클래스는 내부 구현이 바뀔 수 있다 따라서 문서화도 제대로 해두지 않으면 상위 클래스의 변화에 맞춰 수정 되어야만 한다.
- 상위 클래스에서 메서드를 추가한다면



### 상속의 문제를 해결하는 방법 - 컴포지션
- 기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조
- 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 컴포지션(composition; 구성) 이라고 한다.
- 새 클래스의 인스턴스 메서드들은 ( private 필드로 참조하는 ) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환
    - 이 방식을 전달(forwarding) 이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부름
- 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어난다.
- 새로운 메서드가 추가되더라도 전혀 영향 받지 않음

- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴
- API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한됨.
- 아주 심각한 문제는 클라이언트가 노출된 내부에 직접 접근 할 수 있다는 점.


### 데코레이터 패턴
- 기능을 덧씌운다는 뜻.
- 컴포지션과 전달의 조합은 넓은 의미로 위임(delegation)이라고 부름
    - 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당

### 래퍼 클래스는 단점이 거의 없다.
- 래퍼 클래스가 콜백(callBack) 프레임워크와는 어울리지 않는다는 점만 주의


### 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 함.
- 다르게 말하면 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.
- B가 A인가? 라는 질문에 그렇다 라고 확실할 수 없다면 상속을 사용해서는 안된다.




### 정리
- 상속은 강력, 하지만 캡슐화를 해침
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a관계일 때만 사용해야함
    - 패키지가 다르거나, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있음
- 상속의 취약점을 피하려면 상속대신 컴포지션과 전달을 사용하자.
- 래퍼 클래스는 하위 클래스보다 견고하고 강력