# GC의 종류와 선택

### Garbage?

실행중인 프로그램의 어느 포인터도 접근할 수 없는 객체 ( 참조되지 않는다. )

### JVM의 메모리의 Generation 구조

java8

![1.png](image%2FGC%EC%A2%85%EB%A5%98%EC%99%80%20%EC%84%A0%ED%83%9D%20image%2F1.png)

java 9~12

![2.png](image%2FGC%EC%A2%85%EB%A5%98%EC%99%80%20%EC%84%A0%ED%83%9D%20image%2F2.png)

- 가장 간단한 형태의 가비지 컬렉션 알고리즘은 접근 가능한 모든 객체를 순회하고 남은 객체를 쓰레기로 판단하는 것.
- 하지만 이때 살아있는 객체의 수에 비례하는 시간이 소요된다.
- 규모가 큰애플리케이션에서는 절대 사용하면 안됨

- 가상 머신은 generational collection으로 다양한 가비지 컬렉션 알고리즘을 통합해 사용한다.
- generational collection은 애플리케이션들이 공통적으로 갖고 있는 특성들을 활용해 쓰레기 객체를 처리하는데 필요한 작업량을 최소화 한다.
- 가장 중요한 것은 ‘약한 세대 가설’ → 객체 대부분이 아주 짧은시간 동안만 살아남는다는 내용.

- 메모리는 여러 generation으로 관리되는데 각 세대가 꽉 체워질 때 가비지 컬렉션이 발생하는 것.
- 대부분 객체는 young generation에서 할당되고 또 그곳에서 죽는다.
- young generation이 가득 차면 young geration만을 대상으로 하는 마이너 컬렉션이 발생한다.
- 다른 세대의 가비지는 처리되지 않는다.

- 마이너 컬렉션은  ‘약한 세대 가설’을 전제로 최적화 된 것.
- 컬렉션의 비용은 수집되는 살아있는 객체의 수에 비례하므로, 죽은 객체들로만 가득한 young generation은 매우 빠르게 수집
- young generation에서 살아남은 객체들 중 일부는 마이너 컬렉션동안 tenured generation으로 옮겨진다.
- 결과적으로 tenured generation은 채워지게 되고, 컬렉션의 대상이 되어, 힙 전체를 수집하는 메이저 컬렉션이 발생하게 된다.
- 메이저 컬렉션은 마이너 컬렉션 보다 더 오래 걸리는 편인데, 더 많은 객체가 관련되어 있기 때문

### Perm영역

- Class의 Meta 정보나 Method의 Meta정보, Static변수의 상수 정보들이 저장되는 공간으로 흔히 메타데이터 저장영역이라고도 한다.
- Java8 부터는 Native영역으로 이동하여 Metaspace영역으로 변경되었다.
- 다만, 기존 Perm 영역에 존재하던 Static Object는 Heap영역으로 옮겨져서 GC의 대상이 최대한 될 수 있도록 하였다.

### GC의 종류

**Serial Collector**

- 싱글 스레드를 사용해서 모든 종류의 가비지 컬렉션 작업을 한다.
- 스레드 사이의 커뮤니케이션 오버헤드가 없으므로 상대적으로 효율적이다.
- 멀티 프로세서 하드웨어의 장점을 살릴 수 없기 때문에 싱글 프로세서 머신에 최적화된 방법이다.
- 작은 데이터셋 (최대 100MB정도)를 사용하는 애플리케이션이라면 멀티 프로세서 환경에서도 쓸만하다.
- 하드웨어와 OS 설정에 따라 default로 선택된다.
- -XX:+UseSerialGC 옵션을 사용해서 선택할 수도 있다.
- Mark & Sweep & Compact 알고리즘을 사용한다.

********************************Parallel Collector(throughput collector)********************************

- 마이너 컬렉션을 병렬로 수행
- 가비지 컬렉션 오버헤드를 현저하게 줄일 수 있다.
- 멀티프로세서나 멀티 스레드 하드웨어에서 돌아가는 중-대형 데이터셋을 다루는 애플리케이션을 위한 것.
- -XX:+UseParallelGC 옵션을 사용한다.
- Mark & Sweep & Compact 알고리즘을 사용한다.

**Parallel Compaction ( parallel old gc )**

- 페러렐 컬렉터가 메이저 컬렉션을 병렬도 사용할수 있도록 해준다.
- 페러렐 컴팩터가 없다면 메이저 컬렉션이 싱글 스레드로 돌아가게되 확장성이 제한된다.

**Concurrent Collector**

- 가비지 컬렉션으로 인한 일시정지현상을 짧게 하기 위해 동시에 작업을 수행
- 일시정지 현상을 최소화 하기 위해 수행하는 테크닉이 애플리케이션 퍼포먼스를 감소시킬 수 있다.
- 위 때문에 응**답 시간이 전체 처리율 보다 더 중요**한 중대형 규모의 데이터셋을 다루는 애플리케이션을 위해 설계되었다.

***************************************************Concurrent Mark Sweep(CMS) Collector********************************************************************************

- 가비지 컬렉션 일시 정지가 짧은 것을 선호하는 애플리케이션을 위한 것.
- 리소스를 가비지 컬렉션과 공유할 수 있다.
- heap 메모리 영역의 크기가 클때 적합
- GC의 일시 정지 시간을 줄이는 것이 목적, 크기가 큰 오래된 객체가 있는경우 적합
- -XX:+UseConcMarkSweepGC 옵션으로 CMS 컬렉터를 켤 수 있다.
- Young Generation Collection 알고리즘: Parallel
- Old Generation Collection 알고리즘: Concurrent Mark-Sweep

****************************Concurrent Mark-Sweep 알고리즘****************************

4단계를 따른다.

1. Initial Mark Phase
    - 애플리케이션 일시 정지
    - GC에 싱글 스레드 사용
        - 애플리케이션의 Root set과 직접적으로 관계가 있는 살아있는객체만 마크
2. Concurrent Mark Phase
    - GC 스레드는 GC 작업을 하고 Working 스레드는 애플리케이션 작업을 한다.
    - GC에 싱글 스레드를 사용
        - 바로 전 단계에서 체크한 객체가 바라보고 있는 객체들을 추적해 살아있는지 마크한다.
3. Remark Phase
    - 애플리케이션 일시 정지.
    - GC에 멀티 스레드 사용
    - 마크한 객체를 다시 추적해, 살아있는지 확인
4. Concurrent Sweep Phase
    - 애플리케이션은 멈추지 않고 작업을 계속
    - GC는 싱글 스레드 사용
    - Sweep: 살아있는 객체를 제외한 죽은 객체를 모두 삭제
    - compaction(조각 모음)은 하지 않는다.
        - 따라서 , Sweep을 하다 보면 단편화가 발생
        - Free List를 사용해 단편화를 최소화 한다.

**Garbage-First Gargabe Collector**( ******************************************G1 Garbage Collector)******************************************

- 큰 메모리를 가진 멀티 프로세서 머신을 위한 것.
- 높은 확률로 일시 정지 시간에 대한 목표와 높은 처리율을 달성
- -XX:+UseG1GC 옵션으로 G1컬렉터를 켤 수 있다.
- Young Generation Collection 알고리즘: Snapshot-At-The-Beginning(SATB)
- Old Generation Collection 알고리즘: Snapshot-At-The-Beginning(SATB)

- G1은 물리적 generation 구분을 없애고, 전체 heap을 1MB 단위의 리전(region)들로 다룬다.
- G1 이라는 이름은 가비지로 가득찬 리전부터 컬렉션을 시작한다는 의미.
    - 가비지로 꽉 찬 리전이 발견되면 바로 컬렉션을 돌린다.
- Old 리전의 살아있는 객체는 다른 Old리전으로 옮겨지며 compaction이 이뤄진다.
- G1에서 Young, Old 영역 개념은 고정된 개념이 아님.
    - 객체가 새로 할당되는 리전들의 집합이 Young generation
    - 프로모션이 일어나는 리전의 집합이 Old Generation

G1GC만 Generational GC가 아니라는 점에 주의

**동시 컬렉터와 오버헤드**

- 대부분의 동시 컬렉터는 프로세서 자원과 짧은 메이저 컬렉션 일시 정지 시간을 트레이드 한다.
- 가장 눈에 띄는 오버헤드는 컬렉션의 **동시 처리 부분(concurrent parts)에서 하나 이상의 프로세서를 사용** 하는 것.
- N개의 프로세서가 있는 시스템에서, 컬렉션의 동시 처리 부분은 사용 가능한 프로세서들의  K/N 를 사용한다.

  (1<=K<=N/4) 이며, K의 선택값이나 범위는 변경 될 수 있다.

- 일반적으로 동시 컬렉터에서는 가비지 컬렉션의 **일시 정지가 훨신 짧은 편**이지만 애플리케이션의 **처리율은 다른 컬렉터보다 낮은 경향**이 있다.

- 프로세싱 코어가 둘 이상인 머신에서는 컬렉션의 동시 처리를 작업하는 중에 프로세서를 사용할 수 있으므로, 동시 가비지 컬렉터 스레드는 애플리케이션을 **일시 정지 하지 않는다**.
- 일시 정지 시간은 일반적으로 짧아지지만, 애플리케이션이 사용 가능한 프로세서 리소스는 줄어들게 되며, 애플리케이션이 모든 프로세서 코어를 최대한으로 사용하고 있다면 속도 저하가 발생할 수 있다.
- 코어를 늘리면 N이 증가하므로 동시 가비지 컬렉션으로 인한 프로세서 자원의 감소가 줄어 동시 컬렉션의 이득이 커진다.

- 동시 처리 단계중 하나 이상의 프로세서가 가비지 컬렉션에 사용되기 때문에, 동시 컬렉터는 싱글 코어 머신에서는 아무런 장점이 없다.
- 하지만 1,2 프로세서만 있는 시스템에서는 일시 정지 시간을 줄일 수 있는 별도의 CMS 모드를 사용 할 수 있다. → java se8 에서 deprecated 되었다.

### GC 선택 가이드라인

**********일시 정지 시간 요구 사항이 까다롭지 않다면?**********

- VM이 알아서 선택하게 둔다.
- 필요하다면 heap 사이즈를 조절해본다.

***************************************************애플리케이션이 최대 약 100MB 정도의 작은 데이터셋을 다루는 경우***************************************************

- Serial Collector를 선택
    - `-XX:+UseSerialGC` 옵션으로 킨다

***************************************************애플리케이션이 싱글 프로세서에서 돌아아고, 일시 정지 시간에 대한 요구사항이 없는 경우***************************************************

- VM이 알아서 컬렉터를 선택하게 놔둔다.
- VM이 알아서 잘 선택하겠지만 수동으로 선택하고 싶다면 -XX:+UseSerialGC 옵션을 킨다.

***************************************************애플리케이션의 최고 성능이 가장 중요하고 일시 정지 시간이 1초 이상이어도 상관없는 경우***************************************************

- VM이 알아서 컬렉터를 선택하게 놔둔다.
- VM이 알아서 잘 선택하겠지만 수동으로 선택하고 싶다면 -XX:+UseParallelGC 옵션을 킨다.

**응답 시간이 전체 처리율보다 중요하고 일시 정지 시간이 1초 이아여야 하는 경우**

- Concurrent Collecor를 사용
    - • `-XX:+UseConcMarkSweepGC` 옵션이나 `-XX:+UseG1GC` 옵션

***************************************************그래도 성능이 부족하다면?***************************************************

- heap 사이즈와 generation 사이즈를 조절해 볼것.

********************************************그래도 부족하다면?********************************************

- 컬렉터를 바꾸면서 테스트
- ConcurrentCollector로 일시 정지 시간을 줄여보고, Parallel Collector로 멀티 프로세서 하드웨어의 이점을 살려 전체 처리율을 늘려볼 것.