### 테스트 주도 개발(TDD)의 리듬

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

**당신은 다음과 같은 것에 대해 놀랄 것이다.**

- 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지
- 새 테스트를 톨아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지.
- 얼마나 자주 테스트를 실행하는지.
- 얼마나 수 없이 작은 단계를 통해 리팩토링이 되어가는지.

앞으로 어떤 일을 해야하는지 알려 주고 지금 하는일에 집중 할 수 있도록 도와주며, 언제 일이 다 끝나는지 알려줄 수 있게끔 할일 목록을 완성해보자.

앞으로 할일 목록에 있는 한 항목에 대한 작업을 시작하면 그 항목을 **이런 식으로** 굵은 글씨체로 나타낼 것이다. 작업을 끝낸 항목에는 ~~이런 식으로~~ 줄을 긋도록하자.

또 다른 테스트가 생각나면 할일 목록에 새로운 항목을 추가 할 것이다.

**객체를 만들면서 시작하는 것이 아니라 테스트를 먼저 만들어야 한다.**

### 테스트 주기

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실해하는 것은 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

### 의존성과 중복

스티브 프리만은 테스트와 코드간의 문제는 중복이 아님을 지적한 바 있다.

문제는 테스트와 코드 사이에 존재하는 의존성이다.

즉. 코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 한다는 것이다.

우리의 목표는 코드를 바꾸지 않으면서도 뭔가 의미있는 테스트를 하나 더 작성하는 것인데 현재의 구현으로는 불가능 하다.

의존성(dependendy)는 소프트웨어 개발의 모든 부분에서 핵심적인 문제다.

만약 특정 데이터베이스 벤더가 제공하는 세세ㅏㄴ 기능들을 코드 여기저기에서 사용하는 사오항에서 데이터베이스를 다른 벤더의 제품으로 변경하고자 한다면 코드가 해당 벤더에 대해 의존성을 갖는다는 사실을 알 게 될것이다. 코드를 변경하지 않고는 벤더를 바꿀 수 없다.

의존성이 문제 그 자체라면 중복(duplication)은 문제으 징후다. 중복의 가장 흔한 예는 로직의 중복이다.

중복된 로직이란 동일한 문장이 코드의 여러 장소에 나타나는 것을 의미한다. 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.

**문제 자체는 남겨둔 체로 징후만을 제거하면 다른 어딘가에서 최악의 형태로 문제가 드러나곤 하는 현실 세계의 일반적인 양상과는 달리 프로그램에서는 중복만 제거해주면 의존성도 제거된다.**

**이게 바로  TDD의 두 번째 규칙이 존재하는 이유다.**

**다음 테스트로 진행하기 전에 중복을 제거함으로써 오직 한 가지(only and only one)의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화 하는 것이다.**



### 2장 

일반적인 TDD 주기는 다음과 같다.

1. 테스트를 작성한다. 마음속에있는 오퍼레이션 코드에 어떤 식으로 나타나길 원하는지 생각해보라.

   이야기를 써내려가는 것이다. 원하는 인터페이스를 개발하라. 올바른 답을 얻기위해 필요한 이야기의 모든 요소를 포함시켜라.

2. 실행 가능하게 만든다. 다른 무엇보다도 중요한 것은 빨리 초록 막대를 보는 것이다. 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하라. 만약 깔끔하고 단순한 해법이 있지만 구현하는 데 몇 분 정도 거릴ㄹ것 같으면 일단 적어 놓은 뒤에 원래 문제(초록 막대를 보는 것)로 돌아오자.
   미적인 문제에 대한 이러한 전환은 몇몇 숙련된 소프트웨어 공학자들에게는 어려운 일이다.
   그들은 오로지 좋은 공학적 규칙들을 따르는 방법만 알 뿐이다. 빨리 초록 막대를 보는 것은 모든 죄를 사해준다. 하지만 아주 잠시 동안만이다.
3. 올바르게 만든다.이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자. 좁고 올곧은 소프트웨어 정의(software righteousness)의 길로 되돌아와서 종복을 제거하고 초록 막대로 되돌리자.

우리 목적은 작동하는 깔끔한 코드는 얻는 것.

작동하는 깔끔한 코드를 얻는것은 때로는 최고의 프로그래머들조차 도달하기 힘든 목표고,

대부분의 평범한 프로그래머들에게는 거의 불가능한 일이다. 그렇다면 나누어서 정복하자(divide and conquer)

일단 '작동하는 깔끔한  코드'를 얻어야 한다는 전체 문제 중에서 '작동하는'에 해당하는 부분을 먼저 해결하라.

그러고 나서 '깔끔한 코드' 부분을 해결하는 것이다. 이러한 접근 방식은 '깔끔한 코드' 부분을 먼저 해결한 후에, '작동하는' 부분을 해결해 가면서 배운것들을 설계에 반영하느라 허둥거리는 아키텍처 주도 개발(archi-tecture-driven development)과 정반대다.

### 최대한 빨리 초록색을 보기 위해 취할 수 있는 전략 2가지

- 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
- 명백한 구현 사용하기 : 실제 구현을 입력한다.

예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법은 사용하면서 올바른 코드로 리팩토링한다.


### 3장 
객체를 값처럼 쓸 수 있는데 이것은 **값 객체 패턴 (value object pattern)**이라고 한다.

값 객체에 대한 제약사항중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것.

값 객체를 사용하면 별칭 문제를 걱정할 필요가 없다는 아주 큰 장점이 있다.

값 객체가 암시하는 것 중 하나는 2장에서와 같이 모든 연산은 새 객체를 반환해야 한다는 것.

또다른 암시는 값 객체는 equals()를 구현해야 한다는 것인데, 왜냐하면 5$라는 것은 다른 5$만큼이나 똑같이 좋은 것이기 때문이다.

### 5장
우리 주기에는 서로다른 단계들이 있다.

1. 테스트 작성
2. 컴파일되게 하기.
3. 실패하는지 확인하기위해 확인
4. 실행하게 만듦
5. 중복 제거

각 단계에는 서로 다른 목적이 있다. 다른 스타일의 해법, 다른 미적 시각을 필요로 한다.

처음 네 단계는 빨리 진행해야 한다. 그러면 새 기능이 포함되더라도 잘 알고 있는 상태에 이를 수 있다. 거기에 도달하기 위해서라면 어떤 죄든 저지를 수 있다. 그동안 만큼은 속도가 설계보다 더 높은 패 이기 때문이다.

주기의 다섯 번째 단계 없이는 앞의 네 단계도 제대로 되지 않는다. 적절한 시기에 적절한 설계를 돌아가게 만들고 올바르게 만들어라.

### 6장
중복을 처리하는 방법

클래스중 하나가 다른 클래스를 상속받게 하는 것.

두 클래스의 공통 상위 클래스를 찾아 낸다.

적절한 테스트를 갖지 못한 코드에서 TDD를 해야하는 경우가 종종 있을 것이다.

충분한 테스트가 없다면 지원 테스트가 갖춰지지 않은 리팩토링을 만나게 될 수 밖에 없다.

리팩토링 하면서 실수했는데도 불구하고 테스트가 여전히 통과할 수도 있는 것이다. 어떻게 할 것인가?

있으면 좋을 것 같은 테스트를 작성하라.그렇게 하지 않으면 결국에는 리팩토링하다 뭔가 깨트릴 것이다.  리팩토링 하기 전에 테스팅을 하자.

### 8장
하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한발짝 더 다가섰다고 할 수 있다.

하위클래스의 존재를 테스트에서 분리(decoupling)함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 된다.

### 13장
클래스를 명시적으로 검사하는 코드가 있을 때에는 항상 다형성을 사용하도록 바꾸는 것이 좋다.


### 작성한 테스트에 대한 지표

- 명령문 커버리지(statement coverage)는 테스트의 질에 대한 충분한 평가 기준이 될 수 없음이 확실하지만, 테스트의 시작점이다. TDD는 100%의 명령문 커버리지를 종교적으로 따른다. JProbe(www.sitraka.com/software/jprobe)는 오직 한 메서드의  단 한줄(Money.toString())만이 테스트 케이스에 의해 검증되지 않는다고 보고하는데, 이 메서드는 실제 모델코드를 위해서 작성한 것이 아니라 디버깅을 위해 작성한 것이다.
- 결함 삽입(defect insertion)은 테스트의 질을 평가하는 또 다른 방법이다.
  원리는 간단하다. 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다.
  이 작업은 수동으로 할 수도 있지만 Jester(jester.sourceforge.net) 같은 툴을 사용할 수도 있다.
  Jester는 내용을 변경해도 테스트가 실패하지 않는 단 한줄(Pair.hashCode())의 토드가 있다고 보고하는데, 무조건 0을 반환하도록 한 곳이다. 0대신 다른 상수를 반환하도록 해도 실제로 프로그램의 의미가 변하지 않음으므로 Jester가 삽입한 것을 실제로 결함(defect)이라고 볼 수는 없다.

이책의 리뷰어중 한 사람인 플립(Phlip)이 테스트 커버리지에 대해 한 이야기가 있는데 여기서 되풀이할 가치가 있다.
전체 커버리지 수치는 프로그램의 서로 다른 경우를 테스트하는 테스트수를 테스팅이 필요한 경우의수( 로직의 복잡도)로 나눈 것이다.
테스트 커버리지를 향상시키는 한가지 방법은 더 많은 테스트를 작성하는 건데, 테스트 주도 개발자가 작성하는 테스트 코드의 수와 전문 테스터가 작성하는 테스트 코드의 수 사이의 엄청난 차이가 여기에서 온다.

또 다른 방법은 테스트의 수는 그대로 두면서 프로그램의 로직을 단순화하는 것이다.
리팩토링 단계가 종종 다음과 같은 효과를 가져온다.
조건문이 메시징으로 바뀌거나 아예 사라진다. 플립의 말을 빌자면 "모든 입력의 경우(좀더 정확히 말하자면 가능한 모든 경우를 효율적으로 줄인 샘플)를 따져서 테스트 커버리지를 높이는 대신에 우리는 테스트는 그대로 두고 코드를 줄여서 테스트가 다양한 경우를 다루게 한다.


### 테스트 주도 개발 패턴
### 테스트(명사)

테스트하다(test)는 '평가하다 라는 뜻의 동사다.

양성 피드백 고리

스트레스를 많이 받으면 테스트를 점점 더 뜸하게 한다.

테스트를 뜸하게 하면 당신이 만드는 에러는 점점 많아질 것이다.

에러가 많아지면 더 많은 스트레스를 받게 된다.

씻어내고 다시 반복하라(rinse and repeat)

### 격리된 테스트

테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가? 아무 영향이 없어야 한다.

교훈

테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자는 것.

→ 내가만든 에러를 다른 누구보다 먼저 내가 잡을 수 있고, 더 이상 악몽같은 아침도 없을 거다.

어마어마한 양의 종이더미가 반드시 어마어마한 양의 문제를 의미하는 것은 아니라는 점이다.

앞 부분에서 실행된 테스트가 실패한 후 그영향으로 다음 테스트부터는 시스템이 예측불가능한 상태에 놓이는 경우가 허다하다.

테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다는 것.

주된 교훈은 각각의 테스트는 다른 테스트와 완전히 독립적 이어야한다.

즉. 문제가 하나면 테스트도 하나만 실패해야하고 문제가 둘이면 테스트도 두 개만 실패해야 한다.

성능 문제는 테스트가 데이터를 공유해야 하는 이유로 자주 언급된다.

주어진 문제를 작은 단위로 분리하기 위해 노력해서 각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있게 해야 한다는 것이다.

테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.

### 테스트 목록

시작하기 전에 작성해야할 테스트 목록을 모두 적어둘 것.

새로운 항목이 나타나면 나는 빠르고 의식적으로 이 항목이 '지금'할일에 속하는지 '나중에' 할일에 속하는지, 또는 할 필요가 없는 일인지를 결정한다.

이를 테스트 주도 개발에 적용하면  구현해야할 것들에 대한 테스트를 목록에 적는다.

우선 구현할 필요가 있는 모든 오퍼레이션의 사용예들을 적는다.

그 다음, 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널 버전(아무 일도 하지 않는 버전) 을 리스트에 적는다. 마지막으로 깔끔한 코드를 얻기위해 이번 작업을 끝내기 전에 반드시 해야할 리팩토링 목록을 적는다.

테스트를 한번에 다 만들어 놓는 방법이 먹히지 않았던 두 가지 이유

첫째 만들어진 모든 테스트는 리팩토링에 대한 약간의 관성을 갖는다.
자동화된 리팩토링 도구 (예를 들어 변수의 선언부와 모든 참조를 찾아서 한번에 이름 바꾸기를 수행해 주는 메뉴 항목 같은 것) 가 있다면 이것은 별 문제가 안 된다. 그렇지 않다면 열 개의 테스트를 만들 후에 매개 변수의 순서를 반대로 하는 게 좋을 거라는 사실을 발견하더라도 여러분은 아마 이 순서를 바꾸지 않으려 할 것이다.

둘째

열개의 테스트가 실패했다면 초록 막대를 보는 것은 한참 멀었다. 빨리 초록 막대를 볼 방법은 열 개의 테스트를 몽땅 지워버리는 것뿐이다.

만약 모든 테스트가 통과하도록 하려면 오랫동안 빨간 막대 상태에 머물러야 한다.

테스트를 통과하게 만드는 과정에서 여러분이 작성한 코드들은 새로운 테스트가 필요함을 암시적으로 알려줄 것이다. 이 새 테스트를 리팩토링과 마찬가지로 할일 목록에 적어 놓아라.

세션이 끝났을 때 목록에 남아 있는 항목들은 따로 신경 쓸 필요가 있다.

어떤 기능을 하나 진행하는 중이라면 다음 번에도 똑같은 목록을 사용하라.

현재 작업 범위를 넘어서는 큰 리팩토링 거리를 발견한다면, '다음' 할일 목록으로 옮겨라.

나는 테스트 케이스 하나라도 '다음' 목록으로 넘긴 기억이 없다.

제대로 작동하지 않는 테스트를 하나라도 생각할 수 있다면, 그걸 제대로 되게 하는 것이 코드를 릴리즈하는 것보다 더 중요하다.

### 테스트 우선

테스트를 언제 작성하는 것이 좋을까? 테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.

코드를 작성한 후에는 테스트를 만들지 않을 것이다. 프로그래머로서 여러분의 목표는 기능이 실행 되도록 만드는 것이다. 하지만 또 한편으로는 프로그램의 설계에 대해 생각해볼 시간도 필요하고 작업 범위를 조절할 방법도 필요할 것이다.

스트레스를 받을수록 테스트가 충분치 못할 가능성이 높아진다.

테스트를 충분히 하지 못했다고 생각하면 스트레스는 더 커진다. 양성 피드백고리다.

이번에도 역시 이 고리에서 빠져나갈 방법이 필요하다.

테스트를 먼저 해야 한다는 규칙을 도입

→ 영향도를 뒤집을 수 있고 효과적인 주기를 만들어내게 된다.

위쪽에 있는 '테스트 먼저'가 아래쪽에 있는 스트레스에 음성적으로 연결된다.

하지만 스트레스를 유발하는 다른 원인들이 많기 때문에 테스트는 또 다른 효과적인 주기의 영향도 함께 받아야 할 것이다. 그렇지 않으면 스트레스가 높아지면 다시 테스트하지 않게 될지도 모른다.

그러나 테스트가 주는 즉각적인 이익들( 테스트는 프로그램 설계와 작업 범위 조절에 유용하다)는 스트레스가 어느 정도 존재할 때도 테스트를 작성하는 것이 좋음을 우리에게 알려준다.

### 단언 우선

테스트를 작성할 때 단언(assert)은 언제쯤 쓸까? 단언을 제일 먼저 쓰고 시작하다.

자기 유사성(self-similarity)이란 참 멋지지 않은가?

- 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떤 거라고 알려주는 이야기 부터 작성한다.
- 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.
- 테스트를 개발할떄 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.

단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다.

구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 사실 여러분은 몇 가지 문제들을 한번에 해결하는 것이다.

- 테스트하고자 하는 기능이 어디에 속하는 걸까? 기존의 메서드를 수정해야하나, 기존의 클래스에 새로운 메서드를 추가해야 하나, 아니면 이름이 같은 메서드를 새 장소에? 또는 새 클래스에?
- 메서드 이름은 뭐라고 해야 하나?
- 올바른 결과를 어떤 식으로 검사할 것인가?
- 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?

### 테스트 데이터

테스트할 때 어떤 데이터를 사용해야 하는가? 테스트를 읽을 때 쉽고 따라가기 좋을만한 데이터를 사용하라.

테스트 작성에도 청중이 존재한다.

단지 데이터 값을 산발하기 위해 데이터 값을 산발하지 마라.

데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야한다.

1과 2사이에 어떠한 개념적 차이점도 없다면 1을 사용하라.

테스트 데이터 패턴이 완전한 확신을 얻지 않아도 되는 라이선스는 아니다. 만약 시스템이 여러 입력을 다루어야 한다면 테스트 역시 여러 입력을 반영해야 한다.

하지만 세 항목만으로 동일한 설계와 구현을 이끌어낼 수 있다면 굳이 항목을 열 개나 나열할 필요는 없다.

테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는것.

테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다. 실제 데이터는 다음과 같은 경우에 유용한다.

- 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
- 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우(병렬 테스팅)
- 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우.

  특히 부동소수점 값이 정확성이 문제가 될 수 있다.


### 명백한 데이터

데이터의 의도를 어떻게 표현할 것인가? 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.

테스트를 작성할 때는 컴퓨터뿐 아니라 후에 코드를 읽을 다른 사람들도 생각해야 한다.

명백한 데이터가 주는 또 다른 이점은 프로그래밍이 더 쉬워진다는 것이다.

단언 부분에 일단 수식을 써놓으면 다음으로 무엇을 해야할 지 쉽게 알게 된다.

병백한 데이터는 코드에 매직넘버(프로그램 로직 안에 상수를 직접 쓰는 것을 의미, 일반적으로 적절한 이름의 기호상수를 정의해 사용하는 것이 좋다.)를 쓰지 말라는 것에 대한 예외적인 규칙일 수도 있다.

단일 메서드의 범위에서라면 5라는 숫자 (어떤 매직넘버) 사이의 관계는 명백하다.

하지만 이미 정의된 기호 상수가 있다면 나는 그것을 사용할 것이다.

### 시작 테스트

어떤 테스트부터 시작하는게 좋을까? 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트할 것.

새 오퍼레이션에 대한 첫 질문은 다음과 같을 것이다.

"이 오퍼레이션을 어디에 넣어야 하지?" 이 질문에 답하기 전까지는 테스트에 뭘 적어야 할지 알 수 없을 것이다. 한 번에 한 문제만 해결하자는 의미에서 다른 질문은 다 빼고 딱 이 질문만 생각할 방법은 무엇인가?

첫 걸음으로 현실적인 테스트를 하난 작성한다면 상당히 많은 문제를 한번에 해결해야 하는 상황이 될 것이다.

- 이 오퍼레이션을 어디에 두어야 하나?
- 적절한 입력 값은 무엇인가?
- 이 입력들이 주어졌을 때 적절한 출력은 무었인가?

현실적인 테스트 하나로 시작하면 너무 오랫동안 피드백에 없을 것이다.

빨강/초록/리팩토링, 빨강/초록/리팩토링. 이 고리가 몇 분이내로 반복되길 원할 것이다.

정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.

예를 들어 XP 뉴스그룹에 누군가가 다각형 축소기를 테스트 우선으로 어떻게 작성할지 질문했다. 입력은 다각형 그물이고, 출력은 정확하게 똑같은 표면이면서 가능한 한 최소 개수의 다각형 으로 구성된 다각형 그물이 된다. "테스트를 작동하도록 하는 데 박사 학위 논문을 읽어야 하는 경우, 이 문제를 어떻게 테스트 주도로 접근할 수 있을까요?"

시작 테스트 패턴이 이 문제에 대한 답을 준다.

- 출력이 입력과 같은 경우가 있다. 어떤 형상(configuration)의 다격형들은 이미 정규화 되어 있고 더 축소할 수 없다.
- 입력은 가능한 한 적어야 한다. 이를테면 다각형 하나 또는 아예 비어있는 다각형 목록일 수도 있다.

한 단계 테스트는 시작 테스트에도 적용된다. 당신에게 뭔가를 그르쳐 줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라. 만약 당신이 어던 애플리케이션을 n번째 구현하고 있다면 오퍼레이션을 한두 개 필요로 하는 테스트를 하나 골라라.

