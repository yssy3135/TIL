### 테스트 주도 개발(TDD)의 리듬

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

**당신은 다음과 같은 것에 대해 놀랄 것이다.**

- 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지
- 새 테스트를 톨아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지.
- 얼마나 자주 테스트를 실행하는지.
- 얼마나 수 없이 작은 단계를 통해 리팩토링이 되어가는지.

앞으로 어떤 일을 해야하는지 알려 주고 지금 하는일에 집중 할 수 있도록 도와주며, 언제 일이 다 끝나는지 알려줄 수 있게끔 할일 목록을 완성해보자.

앞으로 할일 목록에 있는 한 항목에 대한 작업을 시작하면 그 항목을 **이런 식으로** 굵은 글씨체로 나타낼 것이다. 작업을 끝낸 항목에는 ~~이런 식으로~~ 줄을 긋도록하자.

또 다른 테스트가 생각나면 할일 목록에 새로운 항목을 추가 할 것이다.

**객체를 만들면서 시작하는 것이 아니라 테스트를 먼저 만들어야 한다.**

### 테스트 주기

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실해하는 것은 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

### 의존성과 중복

스티브 프리만은 테스트와 코드간의 문제는 중복이 아님을 지적한 바 있다.

문제는 테스트와 코드 사이에 존재하는 의존성이다.

즉. 코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 한다는 것이다.

우리의 목표는 코드를 바꾸지 않으면서도 뭔가 의미있는 테스트를 하나 더 작성하는 것인데 현재의 구현으로는 불가능 하다.

의존성(dependendy)는 소프트웨어 개발의 모든 부분에서 핵심적인 문제다.

만약 특정 데이터베이스 벤더가 제공하는 세세ㅏㄴ 기능들을 코드 여기저기에서 사용하는 사오항에서 데이터베이스를 다른 벤더의 제품으로 변경하고자 한다면 코드가 해당 벤더에 대해 의존성을 갖는다는 사실을 알 게 될것이다. 코드를 변경하지 않고는 벤더를 바꿀 수 없다.

의존성이 문제 그 자체라면 중복(duplication)은 문제으 징후다. 중복의 가장 흔한 예는 로직의 중복이다.

중복된 로직이란 동일한 문장이 코드의 여러 장소에 나타나는 것을 의미한다. 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.

**문제 자체는 남겨둔 체로 징후만을 제거하면 다른 어딘가에서 최악의 형태로 문제가 드러나곤 하는 현실 세계의 일반적인 양상과는 달리 프로그램에서는 중복만 제거해주면 의존성도 제거된다.**

**이게 바로  TDD의 두 번째 규칙이 존재하는 이유다.**

**다음 테스트로 진행하기 전에 중복을 제거함으로써 오직 한 가지(only and only one)의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화 하는 것이다.**



### 2장 

일반적인 TDD 주기는 다음과 같다.

1. 테스트를 작성한다. 마음속에있는 오퍼레이션 코드에 어떤 식으로 나타나길 원하는지 생각해보라.

   이야기를 써내려가는 것이다. 원하는 인터페이스를 개발하라. 올바른 답을 얻기위해 필요한 이야기의 모든 요소를 포함시켜라.

2. 실행 가능하게 만든다. 다른 무엇보다도 중요한 것은 빨리 초록 막대를 보는 것이다. 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하라. 만약 깔끔하고 단순한 해법이 있지만 구현하는 데 몇 분 정도 거릴ㄹ것 같으면 일단 적어 놓은 뒤에 원래 문제(초록 막대를 보는 것)로 돌아오자.
   미적인 문제에 대한 이러한 전환은 몇몇 숙련된 소프트웨어 공학자들에게는 어려운 일이다.
   그들은 오로지 좋은 공학적 규칙들을 따르는 방법만 알 뿐이다. 빨리 초록 막대를 보는 것은 모든 죄를 사해준다. 하지만 아주 잠시 동안만이다.
3. 올바르게 만든다.이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자. 좁고 올곧은 소프트웨어 정의(software righteousness)의 길로 되돌아와서 종복을 제거하고 초록 막대로 되돌리자.

우리 목적은 작동하는 깔끔한 코드는 얻는 것.

작동하는 깔끔한 코드를 얻는것은 때로는 최고의 프로그래머들조차 도달하기 힘든 목표고,

대부분의 평범한 프로그래머들에게는 거의 불가능한 일이다. 그렇다면 나누어서 정복하자(divide and conquer)

일단 '작동하는 깔끔한  코드'를 얻어야 한다는 전체 문제 중에서 '작동하는'에 해당하는 부분을 먼저 해결하라.

그러고 나서 '깔끔한 코드' 부분을 해결하는 것이다. 이러한 접근 방식은 '깔끔한 코드' 부분을 먼저 해결한 후에, '작동하는' 부분을 해결해 가면서 배운것들을 설계에 반영하느라 허둥거리는 아키텍처 주도 개발(archi-tecture-driven development)과 정반대다.

### 최대한 빨리 초록색을 보기 위해 취할 수 있는 전략 2가지

- 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
- 명백한 구현 사용하기 : 실제 구현을 입력한다.

예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법은 사용하면서 올바른 코드로 리팩토링한다.


### 3장 
객체를 값처럼 쓸 수 있는데 이것은 **값 객체 패턴 (value object pattern)**이라고 한다.

값 객체에 대한 제약사항중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것.

값 객체를 사용하면 별칭 문제를 걱정할 필요가 없다는 아주 큰 장점이 있다.

값 객체가 암시하는 것 중 하나는 2장에서와 같이 모든 연산은 새 객체를 반환해야 한다는 것.

또다른 암시는 값 객체는 equals()를 구현해야 한다는 것인데, 왜냐하면 5$라는 것은 다른 5$만큼이나 똑같이 좋은 것이기 때문이다.

### 5장
우리 주기에는 서로다른 단계들이 있다.

1. 테스트 작성
2. 컴파일되게 하기.
3. 실패하는지 확인하기위해 확인
4. 실행하게 만듦
5. 중복 제거

각 단계에는 서로 다른 목적이 있다. 다른 스타일의 해법, 다른 미적 시각을 필요로 한다.

처음 네 단계는 빨리 진행해야 한다. 그러면 새 기능이 포함되더라도 잘 알고 있는 상태에 이를 수 있다. 거기에 도달하기 위해서라면 어떤 죄든 저지를 수 있다. 그동안 만큼은 속도가 설계보다 더 높은 패 이기 때문이다.

주기의 다섯 번째 단계 없이는 앞의 네 단계도 제대로 되지 않는다. 적절한 시기에 적절한 설계를 돌아가게 만들고 올바르게 만들어라.

### 6장
중복을 처리하는 방법

클래스중 하나가 다른 클래스를 상속받게 하는 것.

두 클래스의 공통 상위 클래스를 찾아 낸다.

적절한 테스트를 갖지 못한 코드에서 TDD를 해야하는 경우가 종종 있을 것이다.

충분한 테스트가 없다면 지원 테스트가 갖춰지지 않은 리팩토링을 만나게 될 수 밖에 없다.

리팩토링 하면서 실수했는데도 불구하고 테스트가 여전히 통과할 수도 있는 것이다. 어떻게 할 것인가?

있으면 좋을 것 같은 테스트를 작성하라.그렇게 하지 않으면 결국에는 리팩토링하다 뭔가 깨트릴 것이다.  리팩토링 하기 전에 테스팅을 하자.

### 8장
하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한발짝 더 다가섰다고 할 수 있다.

하위클래스의 존재를 테스트에서 분리(decoupling)함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 된다.

### 13장
클래스를 명시적으로 검사하는 코드가 있을 때에는 항상 다형성을 사용하도록 바꾸는 것이 좋다.


### 작성한 테스트에 대한 지표

- 명령문 커버리지(statement coverage)는 테스트의 질에 대한 충분한 평가 기준이 될 수 없음이 확실하지만, 테스트의 시작점이다. TDD는 100%의 명령문 커버리지를 종교적으로 따른다. JProbe(www.sitraka.com/software/jprobe)는 오직 한 메서드의  단 한줄(Money.toString())만이 테스트 케이스에 의해 검증되지 않는다고 보고하는데, 이 메서드는 실제 모델코드를 위해서 작성한 것이 아니라 디버깅을 위해 작성한 것이다.
- 결함 삽입(defect insertion)은 테스트의 질을 평가하는 또 다른 방법이다.
  원리는 간단하다. 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다.
  이 작업은 수동으로 할 수도 있지만 Jester(jester.sourceforge.net) 같은 툴을 사용할 수도 있다.
  Jester는 내용을 변경해도 테스트가 실패하지 않는 단 한줄(Pair.hashCode())의 토드가 있다고 보고하는데, 무조건 0을 반환하도록 한 곳이다. 0대신 다른 상수를 반환하도록 해도 실제로 프로그램의 의미가 변하지 않음으므로 Jester가 삽입한 것을 실제로 결함(defect)이라고 볼 수는 없다.

이책의 리뷰어중 한 사람인 플립(Phlip)이 테스트 커버리지에 대해 한 이야기가 있는데 여기서 되풀이할 가치가 있다.
전체 커버리지 수치는 프로그램의 서로 다른 경우를 테스트하는 테스트수를 테스팅이 필요한 경우의수( 로직의 복잡도)로 나눈 것이다.
테스트 커버리지를 향상시키는 한가지 방법은 더 많은 테스트를 작성하는 건데, 테스트 주도 개발자가 작성하는 테스트 코드의 수와 전문 테스터가 작성하는 테스트 코드의 수 사이의 엄청난 차이가 여기에서 온다.

또 다른 방법은 테스트의 수는 그대로 두면서 프로그램의 로직을 단순화하는 것이다.
리팩토링 단계가 종종 다음과 같은 효과를 가져온다.
조건문이 메시징으로 바뀌거나 아예 사라진다. 플립의 말을 빌자면 "모든 입력의 경우(좀더 정확히 말하자면 가능한 모든 경우를 효율적으로 줄인 샘플)를 따져서 테스트 커버리지를 높이는 대신에 우리는 테스트는 그대로 두고 코드를 줄여서 테스트가 다양한 경우를 다루게 한다.