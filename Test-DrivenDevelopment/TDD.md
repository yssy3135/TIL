### 테스트 주도 개발(TDD)의 리듬

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

**당신은 다음과 같은 것에 대해 놀랄 것이다.**

- 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지
- 새 테스트를 톨아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지.
- 얼마나 자주 테스트를 실행하는지.
- 얼마나 수 없이 작은 단계를 통해 리팩토링이 되어가는지.

앞으로 어떤 일을 해야하는지 알려 주고 지금 하는일에 집중 할 수 있도록 도와주며, 언제 일이 다 끝나는지 알려줄 수 있게끔 할일 목록을 완성해보자.

앞으로 할일 목록에 있는 한 항목에 대한 작업을 시작하면 그 항목을 **이런 식으로** 굵은 글씨체로 나타낼 것이다. 작업을 끝낸 항목에는 ~~이런 식으로~~ 줄을 긋도록하자.

또 다른 테스트가 생각나면 할일 목록에 새로운 항목을 추가 할 것이다.

**객체를 만들면서 시작하는 것이 아니라 테스트를 먼저 만들어야 한다.**

### 테스트 주기

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실해하는 것은 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

### 의존성과 중복

스티브 프리만은 테스트와 코드간의 문제는 중복이 아님을 지적한 바 있다.

문제는 테스트와 코드 사이에 존재하는 의존성이다.

즉. 코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 한다는 것이다.

우리의 목표는 코드를 바꾸지 않으면서도 뭔가 의미있는 테스트를 하나 더 작성하는 것인데 현재의 구현으로는 불가능 하다.

의존성(dependendy)는 소프트웨어 개발의 모든 부분에서 핵심적인 문제다.

만약 특정 데이터베이스 벤더가 제공하는 세세ㅏㄴ 기능들을 코드 여기저기에서 사용하는 사오항에서 데이터베이스를 다른 벤더의 제품으로 변경하고자 한다면 코드가 해당 벤더에 대해 의존성을 갖는다는 사실을 알 게 될것이다. 코드를 변경하지 않고는 벤더를 바꿀 수 없다.

의존성이 문제 그 자체라면 중복(duplication)은 문제으 징후다. 중복의 가장 흔한 예는 로직의 중복이다.

중복된 로직이란 동일한 문장이 코드의 여러 장소에 나타나는 것을 의미한다. 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.

**문제 자체는 남겨둔 체로 징후만을 제거하면 다른 어딘가에서 최악의 형태로 문제가 드러나곤 하는 현실 세계의 일반적인 양상과는 달리 프로그램에서는 중복만 제거해주면 의존성도 제거된다.**

**이게 바로  TDD의 두 번째 규칙이 존재하는 이유다.**

**다음 테스트로 진행하기 전에 중복을 제거함으로써 오직 한 가지(only and only one)의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화 하는 것이다.**