네가지 영역을 구성할 때 많이 사용하는 아키텍처는 아래 그림과 같은 계층 구조

![img.png](image%2Fimg.png)

- **계층구조는 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.**
- 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 함.
- 응용 계층은 하위 계층인 도메인 계층에 의존하지만 외부 시스템과 연동을 위해 더 하위 계층인 인프라 계층에 의존하기도 한다.

![img_1.png](image%2Fimg_1.png)![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953c3ac1-7160-4840-9fbb-1279d67bd1e4/Untitled.png)

- 응용 영역과 도메인 영역은 DB나 외부 시스템 연동을 위해 인프라의 기능을 사용하므로 계층구조를 사용하는 것은 직관적으로 이해하기 쉽다.
- 하지만 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라계층에 종속된다.

**인프라 영역에 의존한다면 발생하는 문제점**

- 해당 서비스만 테스트하기 어렵다.
- 구현 방식을 변경하기 어렵다.

## ************************그럼 어떻게 해결할까? →  DIP************************

**고수준 모듈**

- 의미 있는 단일 기능을 제공하는 모듈
- 고수준 모듈의 기능을 구현하려면 여러 하위 기능이 필요

**************************저수준 모듈**************************

- 하위 기능을 실제로 구현한 것.

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 함.

하지만 고수준 모듈이 저수준 모듈을 사용하면 **구현 변경, 테스트가 어렵다는** 두가지 문제가 발생

### **DIP는 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다!**

고수준 모듈을 구현하려면 저수준 모듈을 사용해야 한다.

**어떻게 저수준 모듈이 고수준 모듈에 의존하도록 할까?**

추상화한 인터페이스를 사용한다.

![img_2.png](image%2Fimg_2.png)

위 그림을 예로들면

- CalculateDiscountService는 더이상 직접 구현한 DroolsRuleDiscounter에 의존하지 않는다.
- 추상화한인터페이스 RuleDiscounter에 의존할 뿐이다.
- RuleDiscounter는 ‘룰을 이용한 할인 금액 계산’은 고수준 모듈의 개념
- 따라서 RuleDiscounter인터페이스는 고수준 모듈에 속한다.
- DroolsRuleDiscounter는 고수준의 하위기능인 RuleDiscounter을 구현한 것이므로 저수준 모듈에 속함.

### 그래서 DIP란?

고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 DIP, 의존 역전 원칙 이라고 한다.

**DIP를 사용하면 어떤 장점이 있을까?**

고수준 모듈이 저수준 모듈을 사용하면 구현변경, 테스트가 어렵다는 두가지 문제가 발생한다고 했다.

이 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소할 수 있다.

고수준 모듈은 더이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.

실제 사용할 저수준 구현 객체는 의존 주입을 이용해 전달 받을 수 있다.

```java
// 저수준 객체 생성
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();

//생성자 방식으로 주입
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter);
```

구현 기술을 변경하더라고 저수준 객체만 변경하면 된다.

```java
// 저수준 객체 변경
RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter();

// 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없음.
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter);
```

**실제 구현 없이 테스트 할수 있는 이유도 DIP를 적용해서 고수준 모듈이 저수준 모듈에 의존하지 않도록 했기 때문**

- 고수준 모듈이 인터페이스에 의존하기 때문에 실제 구현 클래스가 없어도 스텁이나 테스트목적의 대역을 사용하여 테스트가 가능하다.

### DIP 주의사항

DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다.

> DIP를 항상 적용할 필요는없다.
사용하는 구현 기술에 따라 완벽한 DIP를 적용하기보다
구현 기술에 의존적인 코드를 일부 포함하는 게 효과적일 때도 있다.
무조건 DIP를 적용하려고 시도하지 말고 DIP의 이점을 얻는 수준에서 적용범위를 검토하자



## 도메인 영역의 주요 구성 요소

### ENTITY - 엔티티

- 고유 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다.

### VALUE - 밸류

- 고유 식별자를 갖지 않는다.
- 개념적으로 하나인 값을 표현할 때 사용한다.
  배송지 주소를 표현하기 위한 주소(Address), 금액과 같은 타입
- 엔티티의 속성뿐 아니라 다른 밸류타입의 속성으로도 사용 가능

### AGGREGATE - 애그리거트

- 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것.

  예를 들어 Order엔티티, OrderLine밸류, Orderer 밸류 객체를 주문 애그리거트로 묶을 수 있음.


### REPOSITORY

- 도메인 모델의 영속성을 처리.

### DOMAIN SERVICE

- 특정 엔티티에 속하지 않은 도메인 로직을 제공

  예를들어 ‘할인금액계산’ 상품, 쿠폰, 회원등급, 구매 금액 등 다양한 조건을 이용해 구현필요.

  도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현


### 도메인 모델의 엔티티와 DB관계형 모델의 엔티티는 같은 것이 아니다.

- 도메일 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다
- 단순히 데이터를 담고있는 데이터 구조보다 데이터와 함께 기능을 제공하는 객체이다.
- 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다.

***************************************************밸류는 불변으로 구현할 것을 권장하며, 이는 엔티티의 밸류 타입 데이터를 변경할 대는 객체 자체를 완전히 교체한다는 것을 의미***************************************************

### 2.4.2 애그리거트

***************************************************모델이 복잡해지면서 따르는 문제***************************************************

- 도메인 모델이 복잡해지면 전체구조가 아닌 한개의 엔티티와 밸류에 집중하는 현상이 발생.
- 상위 수준에서 모델을 관리하지 않고 개별요소에만 초점을 맞추면 상위수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리할 수 없는 상황에 빠진다.
- 도메인 모델도 개별 객체뿐 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는데 도움이 됨.

************************애그리거트************************

- 관련 객체를 하나로 묶은 군집
- 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것
    - 군집 단위로 모델을 바라 볼 수 있음
    - 개별 객체간 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현하게 되며, 이를 통해 큰 틀에서 도메인 모델을 관리할 수 있음.

**********************루트 엔티티**********************

애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖음

- 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공.
- 애그리거트를 사용하면 애그리거트 루트가 제공하는 기능을 사용하고 애그리거트 루트를 통해 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근
    - 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화 할 수 있도록 함.

  ![image](https://github.com/yssy3135/TIL/assets/62733005/f308287c-de94-4322-aeed-0588d432a5c1)


### 리포지터리

- 도메인 객체를 지속적으로 사용하기 위해 로컬 파이로가 같은 물리적인 저장소에 객체를 보관하기위한 도메인 모델
- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
- 리포지터리는 애그리거트 다누이로 도메인 객체를 저장하고 조회하는 기능을 정의한다.

**리포지터리와 서비스**

- 응용 서비스는 의존 주입과 같은 방식을 사용해 실제 리포지터리 구현 객체에 접근
- 응용 서비스는 도메인 객체를 구하거나 저장할때 리포지터리를 사용
- 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받음

### 2.5 요청 처리 흐름

![image](https://github.com/yssy3135/TIL/assets/62733005/2e44dcbd-5248-4e44-93d8-03a428455ae1)

### 인프라스트럭처

- 인프라스트럭처는 표현 영역,응용역역, 도메인 영역을 지원한다.
- 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.
- DIP에서 언급한 것 처럼 도메인 영역과 응용영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게만들어준다.
- 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없음
- 구현의 편리함은 DIP가 주는 장점(변경 유연, 테스트 쉬움) 만큼 중요하기 때문 DIP의 장점을 해지지 않는 범위에서 응용영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 나쁘지 않다.

### 모듈구성

도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성

![image](https://github.com/yssy3135/TIL/assets/62733005/02396252-71ff-4d23-b143-517e004666dd)

도인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성

![image](https://github.com/yssy3135/TIL/assets/62733005/81d63b0f-abd3-4ea5-a02c-adfe285fb27d)

- 애그리거트, 모델, 리포지터리는 같은 패키지에 위치
- 도메인이 복잡하면 도메인 모델과 도메인 서비스를 별도 패키지에 위치시킬 수도 있다.
- 모듈 구조의 세분화에 대한 정해진 규칙은 없음.
- 한 패키지에 너무 많은 타입이 몰려 불편한 정도만 아니면 된다.
    - 한 패키지에 10~15 미만의 타입 개수