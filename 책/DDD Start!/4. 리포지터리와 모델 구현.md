### **Spring Data JPA를 이용한 리포지터리 구현**

JPA매핑을 위한 기본 규칙

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑
- 한테이블에 엔티티와 밸류 데이터가 같이있다면
    - 밸류는 @Embeddable로 매핑
    - 밸류타임 프로퍼티는 @Embedded로 매핑

JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 함

- DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문

**************************밸류를 이용한 ID 매핑**************************

- 밸류타입을 식별자로 매핑하면 @Id 대신 @EmbeddedId 애너테이션을 사용
- JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.
- 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점.


**기본 생성자는 protected로 선언하자.**

- 기본 생정자는 JPA 프로바이더가 객체를 생성할 때만 사용
- 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 된다.

***************************************************엔티티의 필드접근 방식에 get/set 메서드를 추가하는 대신 의도가 잘드러나는 기능을 제공하자.**************************************************

- get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
- 특히 set은 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수 있다.

************************************AttributeConverter************************************

- 두개 이상의 프로퍼티를 가진 밸류타입을 한 개 컬럼에 매핑하려면 @Embeddable 애너테이션으로는 불가능
- 이럴때  AttributeConverter 사용

********한 개 컬럼 매핑********

- 밸류 컬렉션을 별도 테이블이 아닌 한 개 컬럼에 저장해야할 경우에 사용.
- 한개 컬럼에 콤마로 구분해서 저장해야할 경우.
- AttributeConverter를 사용하면 밸류 컬렉션을 할 깨 컬럼에 쉽게 매핑 할 수 있다.

***************************************************밸류를 이용한 ID 매핑***************************************************

- 밸류 타입을 식별자로 매핑하면 @Id대신 EmbeddedId 애너테이션 사용
- JPA 에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속 받아야 함.
- 밸류 타입으로 식별자를 구현했을때 장점은 식별자에 기능을 추가할 수 있다는 점.

***************************************************별도 테이블에 저장하는 밸류 매핑***************************************************

- 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류
- 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해봐야 한다.
- 단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아님.
- 엔티티가 확실하다면 다른 애그리거트는 아닌지 확인해야함.
- 자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.

************************************************************************************************************밸류를 매핑 한 테이블을 지정하기위해 @Secondtable 과 @AttributeOverride를 사용.************************************************************************************************************

**************개념적으로 밸류이지만 Entity를 사용해야 할 때도 있다.**************

**********************************************************상속 구조를 갖는 밸류 타입을 사용**********************************************************

- **********************************************************@Entity를 이용해 상속 매핑으로 처리해야 한다.**********************************************************
- @Entity로 매핑하므로 식별자 매핑을 위한 필드도 추가해야함.
- **구현 클래스를 구분하기 위한 타입 식별 (discriminator) 컬럼도 추가해야 함.**

**Entity와 Embeddable타입의 List delete 차이**

************Entity************

- Entity는 select 쿼리로 대상 엔티티를 로딩하고 각 개별 엔티티에 대해 delete쿼리를 실행
- 변경 빈도가 낮으면 괜찮지만 빈도가 높으면 전체 서비스 성능에 문제가 될 수 있다.

**Embeddable**

- 컬렉션에 속한 객체를 로딩하지 않고 한번의 delete쿼리로 삭제.
- 애그리거트의 특성을 유지하면서 문제를 해소하려면 상속을 포기하고 Embeddable로 매핑된 단일 클래스로 구현해야 함.

### ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85065cab-2bf7-40a8-90ba-c41924609601/Untitled.png)

- 집합의 값에 밸류 대신 연관을 맺는 식별자가 온다.
- ElementCollection을 이용하기 때문에 Product를 삭제할때 매핑에 이용한 조인 테이블의 데이터도 함께 삭제됨.
- 애그리거트를 직접 참조하면 영속성 전파나 로딩 전략을 고민해야하는데 ID 참조를 사용해 고민을 없앨 수 있다.

### 애그리거트 로딩 전략

************************************************************************************************************JPA 매핑을 설정할 때 항상 기억해야 할 점.************************************************************************************************************

- 애그리거트에 속한 객체가 모두 모여야 환전한 하나가 된다.
- 조회 시점에 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시로딩(FetchType.EAGER)로 설정
- 연관된 구성요소를 DB에서 함께 읽는다.

**FetchType.EAGER 는 항상 종은 것은 아니다.**

- 보통 조회 성능 때문에 즉시 로딩 방식을 사용
- 조회되는 데이터 개수가 많아지면 즉시로딩 방식을 사용할 때 성능(실행 빈도, 트래픽, 지연로딩시 실행속도 등)을 검토해야 한다.

**애그리거트가 완전해야 하는 이유**

- 상태를 변경하는 기능을 실행할 때 애그리거트가 완전해야 한다.
- 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하다.

************************************************************************************************************************************************************************************************************************************루트 엔티티를 로딩하는시점에 애그리거트에 속한 객체를 모두 로딩해야하는 것은 아니다!************************************************************************************************************************************************************************************************************************************

- 트랜잭션 범위이 내에서 지연로딩을 허용하기 때문에 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.
- 지연 로딩은 즉시로딩보다 쿼리 실행 횟수가 많아질 수 있다. 애그리거트에 맞게 즉시 로딩과 지연 로딩을 선택해야 한다.

### 애그리거트의 영속성 전파.

**애그리거트가 완전한 상태여야 한다.**

- 조회할 때 뿐만아니라 삭제할 때도 하나로 처리해야 한다.
- @Embeddable 타입은 함께 저장되고 삭제
- @Entity타입의 매핑은 cascade 속성을 사용해 삭제 시 함께 처리되도록 설정해야 한다.

### 식별자 생성 기능

**********************************식별자 생성 3가지 방법**********************************

- 사용자 직접 생성
- 도메인 로직으로 생성
- DB를 이용한 일련번호 사용

************************************************************************************************************************************************************************************************식별자 생성 규칙이 있다면 엔티티가 별도 서비스로 식별자 생성 기능을 분리해야함.************************************************************************************************************************************************************************************************

**식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성기능을 위치시켜야함.**

![image](https://github.com/yssy3135/TIL/assets/62733005/624b781c-7e74-4fa2-a6f6-e6713dec8832)

### 도메인 구현과 DIP

![image](https://github.com/yssy3135/TIL/assets/62733005/64b3068b-6fd8-4638-a1ae-f25f8679aa46)

**********************************************************************도메인이 인프라에 의존한다!**********************************************************************

위 코드는 구현 기술인 JPA에 의존하고 있다.

- 구현 기술에 의존 없이 순수하게 유지하려면 JPA의 Repository를 상속 받지 않고 인터페이스를 구현할 클래스를 인프라에 위치시켜야 한다.
- 애너테이션을 모두 지우고 인프라에 JPA를 연동하기 위한 클래스를 추가해야 한다.

![image](https://github.com/yssy3135/TIL/assets/62733005/64afeecd-db27-42c8-945f-14ee0855fbca)

**DIP를 적용하는 주된 이유**

- 저수준 구현이 변경되더라도 고수준이 영향을 받지 않도록하기 위해.

**************************************리포지터리와 도메인 모델의 구현 기술은 거의 바뀌지 않는다!**************************************

- 변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과하다.
- 어느정도 타협은 필요하다.