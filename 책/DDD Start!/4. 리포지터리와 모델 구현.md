### **Spring Data JPA를 이용한 리포지터리 구현**

JPA매핑을 위한 기본 규칙

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑
- 한테이블에 엔티티와 밸류 데이터가 같이있다면
    - 밸류는 @Embeddable로 매핑
    - 밸류타임 프로퍼티는 @Embedded로 매핑

JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 함

- DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문

**************************밸류를 이용한 ID 매핑**************************

- 밸류타입을 식별자로 매핑하면 @Id 대신 @EmbeddedId 애너테이션을 사용
- JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.
- 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점.


**기본 생성자는 protected로 선언하자.**

- 기본 생정자는 JPA 프로바이더가 객체를 생성할 때만 사용
- 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 된다.

***************************************************엔티티의 필드접근 방식에 get/set 메서드를 추가하는 대신 의도가 잘드러나는 기능을 제공하자.**************************************************

- get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
- 특히 set은 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수 있다.

************************************AttributeConverter************************************

- 두개 이상의 프로퍼티를 가진 밸류타입을 한 개 컬럼에 매핑하려면 @Embeddable 애너테이션으로는 불가능
- 이럴때  AttributeConverter 사용

********한 개 컬럼 매핑********

- 밸류 컬렉션을 별도 테이블이 아닌 한 개 컬럼에 저장해야할 경우에 사용.
- 한개 컬럼에 콤마로 구분해서 저장해야할 경우.
- AttributeConverter를 사용하면 밸류 컬렉션을 할 깨 컬럼에 쉽게 매핑 할 수 있다.

***************************************************밸류를 이용한 ID 매핑***************************************************

- 밸류 타입을 식별자로 매핑하면 @Id대신 EmbeddedId 애너테이션 사용
- JPA 에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속 받아야 함.
- 밸류 타입으로 식별자를 구현했을때 장점은 식별자에 기능을 추가할 수 있다는 점.

***************************************************별도 테이블에 저장하는 밸류 매핑***************************************************

- 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류
- 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해봐야 한다.
- 단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아님.
- 엔티티가 확실하다면 다른 애그리거트는 아닌지 확인해야함.
- 자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.