### 복잡성의 문제

- 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적 구조나 큰 수준에서 도메인간 관계를 파악하기 어려워진다.
- 주요 도메인 요소간 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하기 어렵다!

### 애그리거트?

***************************************************애그리거트와 복잡성***************************************************

- 복잡한 도메인을 이해하고 쉬운 단위로 만들기 위한 상위 수준에서 모델을 조망할 수 있는 방법
- 모델을 이해하는데 도움을 줄 뿐만아니라 일관성을 관리하는 기준도 됨.
    - 애그리거트 단위로 일관성을 관리하기 때문
- 복잡한 도메인을 단순한 구조로 만들어줌.
- 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는데 필요한 노력(개발 시간)도 줄어든다.
- 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖음.

![image](https://github.com/yssy3135/TIL/assets/62733005/00e50f6b-8989-4761-99b2-0ba1830a8237)


******************************************애그리거트의 경계******************************************

- 애그리거트는 경계를 갖음
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
- 독립된 객체로 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않음
- 경계를 설정하는 것은 도메인 규칙과 요구사항
- 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속한 가능성이 높다.
- 함께 변경되는 빈도가 높은 객체도 한 애그리거트에 속할 가능성이 ㄴㅍ다.

## 애그리거트 루트

- **핵심 역할은 애그리거트의 일관성이 깨지지 않도록 유지하는 것.**
- 애그리거트에  속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 주체가 애그리거트의 루트 엔티티
- 애그리거트의 대표 엔티티
- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 됨.
- 애그리거트가 제공하는 도메인 기능을 구현

**애그리거트의 규칙**

- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨.
- 이러면 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨버리게 원인이 된다.

***************************************************불필요한 중복을 제거하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들기***************************************************

- 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
    - 공개 set 메서드를 사용하면 의미나 의도를 표현하지 못함.
    - 도메인 로직을 도메인 객체가 아닌 다른 영역으로 분산시킴.
    - 도메인 로직이 한곳에 응집되지 않음으로 유지보수하기 어려움
- 밸류 타입은 불변으로 구현한다.
    - 밸류 객체의 값을 변경할 수 없으면 애그리거트 루트에서 밸류 객체를 구해서 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없다.
    - 애그리거트 외부에서 내부 상태를 함부로 변경하기 못하므로 일관성이 깨질 가능성이 줄어든다.


***************************************************애그리거트 루트의 기능 구현***************************************************

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해 기능을 완성
- 애그리거트 루트가 구성요소의상태만 참조하는 것은 아님. 기능 실행을 위임하기도 함.
    - get()메소드를 제공하면 외부에서 기능을 실행해 상태를 변경할 수 있기때문
- 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지 할 수 있음.

************************************트랜잭션 범위************************************

- 트랜잭션 범위는 작을수록 좋다.
    - 한 트랜잭션에서 한개 테이블을 수정하면 Lock이 한개 테이블의 한row로 제한되지만 세개의 테이블을 수정하면 잠금 대상이 더 많아짐.
    - 잠금 대상이 더 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것. → 전체적인 성능 ( 처리량 ) 을 떨어뜨린다.
- 한 트랜잭션에서 하나의 애그리거트만 수정해야 한다.
    - 충돌 가능성이 높아져 전체 처리량이 떨어진다.
- 한 트랜잭션에서 하나의 애그리거트만 수정해야 하다는 것은 하나의 애그리거트에서 다른 애그리거트를 수정하면 안된다는 뜻
    - 애그리거트는 최대한 독립적이어야 함.
    - 한 애그리거트가 다른 애그리거트의 기능에 의존하면 결합도가 높아짐.
- 부득이하게 한 트랜잭션에서 두개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현



### 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현
- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재해야 함.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화 해야한다.
- 어떤 기술을 이용해서 리포지터리를 구현하냐에 따라 애그리거트의 구현도 영향을 받음.

### 애그리거트간 참조

- 애그리거트의 관리 주체는 애그리거트 루트  다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한 다는 것.
- 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 함.

************문제점************

- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움.

***************************************************애그리거트간 참조 문제****************************************************

- 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다
- 애그리거트를 직접 참조하면 성능과 관련된 여러 고민을 해야 한다.

**성능** (**JPA사용했을 때 고민)**

- 지연(Lazy), 즉시(eager) 로딩의 두가지 방식으로 로딩할 수 있다.
- 단순히 연관된 객체의 데이터를 함께 화면에 보여줘야한다면 즉시 로딩이 조회 성능에 유리하다.
- 애그리거트의 상태를 변경하는 기능을 실행해야 하는 경우에는 불필요한 객체를 함께 로딩할 필요가 없으므로 지연로딩이 유리할 수 있다.

**확장문제**

- 사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다.
- 이과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 때도 있다.
- 이는 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미.

### ID 참조를 이용해라.

위 문제를 완화하기 위해 사용할 수 있는 것 ID를 이용해서 다른 애그리거를 참조하는 것.

****왜?****

- ID 참조를 사용해면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조.
- 애그리거트의 경계를 명확히 하고 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰줌.
- 애그리거트 간 의존을 제거 응집도를 높여주는 효과도 있다.
- 구현 복잡도도 낮아진다.
- 필요할 때 ID를 이용해서 로딩 ( 지연로딩과 동일한 결과)
- 애그리거트별 다른 구현 기술을 사용하는 것도 가능.

**ID 참조와 조회 성능**

- 애그리거트를 ID참조하면 여러 애그리거트를 참조할때 성능 문제가 발생할 수도 있다.
- 조회 대상이 N개일때 N개를 읽어오는 한번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행한다 → N+1 문제가 발생할 수 있다.

**조회 전용 쿼리를 사용해라! ( JPQL )**

즉시 로딩이나 지연 로딩과 같은 로딩 전략을 고민할 필요 없이 조회 화면에서 필요한 애그리거트 데이터를 한번의 쿼리로 로딩 할 수 있다.

***************************************************애그리거트마다 다른 저장소를 사용하면 쿼리를 여러번 날려야한다. → 성능이슈가 일어날 수 있다.***************************************************

- 조회 성능을 높이기 위해 캐시를 적용
- 조회 전용저장소를 따로 구성
- 코드가 복잡해지는 단점이 있음.
- 시스템의 처리량을 높일 수 있다.
- 특히 한대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 캐시나 조회 전용 저장소는 필수다.





