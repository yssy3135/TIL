### 복잡성의 문제

- 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적 구조나 큰 수준에서 도메인간 관계를 파악하기 어려워진다.
- 주요 도메인 요소간 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하기 어렵다!

### 애그리거트?

***************************************************애그리거트와 복잡성***************************************************

- 복잡한 도메인을 이해하고 쉬운 단위로 만들기 위한 상위 수준에서 모델을 조망할 수 있는 방법
- 모델을 이해하는데 도움을 줄 뿐만아니라 일관성을 관리하는 기준도 됨.
    - 애그리거트 단위로 일관성을 관리하기 때문
- 복잡한 도메인을 단순한 구조로 만들어줌.
- 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는데 필요한 노력(개발 시간)도 줄어든다.
- 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖음.

![image](https://github.com/yssy3135/TIL/assets/62733005/00e50f6b-8989-4761-99b2-0ba1830a8237)


******************************************애그리거트의 경계******************************************

- 애그리거트는 경계를 갖음
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
- 독립된 객체로 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않음
- 경계를 설정하는 것은 도메인 규칙과 요구사항
- 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속한 가능성이 높다.
- 함께 변경되는 빈도가 높은 객체도 한 애그리거트에 속할 가능성이 ㄴㅍ다.

## 애그리거트 루트

- **핵심 역할은 애그리거트의 일관성이 깨지지 않도록 유지하는 것.**
- 애그리거트에  속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 주체가 애그리거트의 루트 엔티티
- 애그리거트의 대표 엔티티
- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 됨.
- 애그리거트가 제공하는 도메인 기능을 구현

**애그리거트의 규칙**

- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨.
- 이러면 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨버리게 원인이 된다.

********************************************************************************************************************************************************************************************************************************불필요한 중복을 제거하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들기********************************************************************************************************************************************************************************************************************************

- 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
    - 공개 set 메서드를 사용하면 의미나 의도를 표현하지 못함.
    - 도메인 로직을 도메인 객체가 아닌 다른 영역으로 분산시킴.
    - 도메인 로직이 한곳에 응집되지 않음으로 유지보수하기 어려움
- 밸류 타입은 불변으로 구현한다.
    - 밸류 객체의 값을 변경할 수 없으면 애그리거트 루트에서 밸류 객체를 구해서 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없다.
    - 애그리거트 외부에서 내부 상태를 함부로 변경하기 못하므로 일관성이 깨질 가능성이 줄어든다.


***************************************************애그리거트 루트의 기능 구현***************************************************

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해 기능을 완성
- 애그리거트 루트가 구성요소의상태만 참조하는 것은 아님. 기능 실행을 위임하기도 함.
    - get()메소드를 제공하면 외부에서 기능을 실행해 상태를 변경할 수 있기때문
- 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지 할 수 있음.

************************************트랜잭션 범위************************************

- 트랜잭션 범위는 작을수록 좋다.
    - 한 트랜잭션에서 한개 테이블을 수정하면 Lock이 한개 테이블의 한row로 제한되지만 세개의 테이블을 수정하면 잠금 대상이 더 많아짐.
    - 잠금 대상이 더 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것. → 전체적인 성능 ( 처리량 ) 을 떨어뜨린다.
- 한 트랜잭션에서 하나의 애그리거트만 수정해야 한다.
    - 충돌 가능성이 높아져 전체 처리량이 떨어진다.
- 한 트랜잭션에서 하나의 애그리거트만 수정해야 하다는 것은 하나의 애그리거트에서 다른 애그리거트를 수정하면 안된다는 뜻
    - 애그리거트는 최대한 독립적이어야 함.
    - 한 애그리거트가 다른 애그리거트의 기능에 의존하면 결합도가 높아짐.
- 부득이하게 한 트랜잭션에서 두개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현