### 모놀리식 아키텍처와 SOA(Service Oriented Architechture)

- 처음 소프트웨어 아키텍처의 시작은 모놀리식
- 모놀로식에서 오는 고통과 제한적인 환경에서 해결하고자 했던 노력에서 나온 아키텍처가 SOA

**모놀리식**

- 하나의 어플리케이션이 하나의 서버에 배포
- 단일 코드베이스
- 싱글/멀티 모듈 방식으로 개발은 가능하지만, 근본적으로 하나의 프로세스

**SOA**

- “서비스” 단위로 개발, 서비스 간 규격화된 프로토콜(인터페이스)를 사용해서 통신
- 대게 동일한 기술 스택들을 가지고 서비스들을 개발
    - 서비스들간의 재사용이 목적 (msa는 재사용이 목적은 아님)
- ESB(Enterprise Service Bus) 라는 개념을 통해, 요청에대해 어떤 서비스들을 호출할 지 캡슐화된 Layer가 존재
- 서비스 간 통합을 강조

### 모놀리식 아키텍처와 SOA

![mo_soa_1.png](images%2Fmo_soa_1.png)

**공통점**

- sharedDB 사용
- 대개 원 코드베이스
- 모듈/서비스 간 규격화된 호출 방식 사용 (서비스 간 통합 관점)
    - 모듈/서비스 간 강한 의존성, 결합도


**SOA만의 특정, 차이점**

- 독립적으로 배포가 가능하다.
- 비즈니스 로직에 따라, 어떤 서비스를 호출할지 결정하는 Layer가 따로 존재한다(ESB)
- 서비스가 분리되어 있기 때문에 트랜잭션 구현을 별개로 해야 한다.
- ESB를 관리 해주어야 한다 (Integration of Monolithic)
    - 누군가가 개발하고 새로운 서비스가 추가된다면 통합을 위한 개발을 수행해 주어야 한다.
    - MSA의 원칙을 정면으로 반박
- 동일 플랫폼(e.g. JVM 환경) 에서 서비스 간 호출을 하다보니 성능 이슈가 존재한다

### SOA와 MSA

![mo_soa_2.png](images%2Fmo_soa_2.png)

**공통점**

- 개발의 단위를 서비스로 인지
- 다른 서비스와 독립적으로 개발, 배포 가능

**MSA만의 특징, 차이점**

**공통점**

- 개발의 단위를 “서비스”로 인지
- 다른 서비스와 독립적으로 개발, 배포 가능

**MSA만의 특징, 차이점**

- 비즈니스 로직(서비스)의 재사용 지양
    - 서비스간 결합도를 낮추는 것이 목표
- 낮은 결합도로 변화에 애자일한 대응이 가능
- 각 서비스는 서비스의 특성에 맞는 최적의 기술스택을 독립적으로 선택이 가능
- 서비스간 자유로운 방식으로 통신 가능
    - HTTP, gRPC, …
    - dump pipe를 만들어라
        - ESB는 smart pipe 요청이 들어오면 어떤 서비스를 어떤 방식으로 요청하고 response 할지 결정하는 역할도 수행
        - input을 전달하는 역활 말고는 아무것도 하지 않음.

## MSA는 어떻게 모놀리식의 문제를 해결할까?

**모놀리식과 SOA의 문제는 뭐야?**

협업, 커뮤니케이션, 확장성, 유연성, 결합도, 응집도, 빌드와 배포,…..

**요구사항 변화에 따른 빠른 대처!!**