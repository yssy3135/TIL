### 대부분의 케이스에서는 트랜잭션을 다양한 기교를 통해 대부분의 수많은 케이스 해결이 가능하다.

기교?

- 단순 Sync 방식 재시도
- DB에 상태 저장 후 비동기 방식 재시도
- Async방식  Dead Letter 처리, (Queueing 활용, Dead Letter Queue)

### 기교가 통하지 않을 수 있는 케이스 → 즉 엄밀히 ‘트랜잭션’ 구현이 필요한 경우

- 기교를 위한 인프라가 적절히 존재하지 않는 경우
- 전 비즈니스에서 트랜잭션에 대한 강한 니즈가 있는경우
- 너무나 Risky(중요한) 비즈니스인 경우(e.g. 금융) , 외부 의존성(시스템)에 제약 사항이 있을 경우(e.g. 재시도 불가)

### MSA 환경에서의 트랜잭션(분산 트랜잭션)

기교 라고 표현한 이유

- MSA 환경에서는 가능하면 정석적인 방법(트랜잭션)은 구현하지 않는 것이 바람직

**왜?**

- 너무 어렵다
- 관리 포인트가 너무나 많이 늘어난다.
- 개발에 필요한 시간이 훨씬 더 많이 늘어난다.

→ MSA의 목적에 주객이 전도되는 현상이 발생할 수 있다.

**분산 트랜잭션을 구현하는 방법**

- 2PC(2 Phase Commit)
- 보상 트랜잭션(Compensating Transaction)

### 트랜잭션과 (Transaction) 과 ACID

- 일련의 작업들을 atomic하게 수행하는 작업의 단위
- 처음에는 데이터베이스쪽에서 나온 용어
- ACID란 트랜잭션이 만족시켜야 하는 4가지 속성
    - Atomicity(원자성)
        - 전체가 수행거나, 혹은 수행되지 않거나의 특성
        - 어느 하나라도 실패시, 이전에 수행된 변경 사항들은 Rollback 과정(보상 트랜잭션)이 필요
    - Consistency(일관성)
        - 트랜잭션 실행 전과 실행 후에, 변경되는 데이터들은 일관성을 유지해야 한다.
        - 즉, 도메인 비즈니스에 따라 약속된 데이터의 변경들만 이루어져야한다. (데이터 적합성 유지)
    - Isolation(고립성)
        - 트랜잭션 간에는, 서로 영향을 마치면 안됨
    - Durability(지속성)
        - 트랜잭션 완료 후, 그 결과는 영구적으로 유지 되어야 한다.

### 2PC (2 Phase Commit)

- 처음엔 다수의 노드를 가지는 데이터베이스(e.g. Mysql)에서 커밋을 구현하기 위한 개념으로 시작
- 의미가 확장되어, 분산 시스템(다수의 노드) 환경에서 트랜잭션을 구현하기 위한 해결 방안 중 하나가 됨
- 하나의 약속 규약(프로토콜) 이라고 볼 수 있다.
- 분산 시스템 환경에서 Cordinator 라는 추가적인 요소(인프라)가 필요
- 그리고 트랜잭션을 위한 서비스들을 Participant(참여자) 라고 정의
- 2 Phase
    - Preapare (Phase1) 준비
    - Commit (Pahse2) 커밋

**Cordinator(조정자)**

- 분산 트랜잭션을 위해 데이터 변경을 수행하는 서버(MSA 환경에서 각 서비스) 들의 Phase를 관리

### 2PC의 프로세스

Start Prepare

1. 트랜잭션이 사직되면 Cordinator가 Global Unique ID(Transaction ID)를 생성
2. Cordinator는 사전에 정의된 각 서비스(Participant)별로 실행해야 할 요청들에 대한 준비를 각 서비스에 요청
3. 모든 Participant가 준비되었다고 응답 ( 실질적 데이터 변경을 일어나지 않은 상태 )

**Prepare** Done **Commit** start

1. Cordinator는 Participant 들에게 Commit 요청
2. Participant들은 이전에 준비했던 동작을 마저 진행하고, 각 서비스들은 실제 데이터 변경을 위한 Commit 진행
3. 모든 participant 에게 OK 응답을 받게되면 트랜잭션 완료

![분산트랜잭션_1.png](images%2F%EB%B6%84%EC%82%B0%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_1.png)

### 2PC의 한계 - 장애 취약성

**Cordinator에 모든 의존성이 있다.**

- Cordinator에 문제가 생기는 순간, 모든 트랜잭션은 멈춰버리고 모든 비즈니스가 정지된다.
- Data에 대한 Lock이 걸림
- 문제가 생기면, 결정 주체가 없어진다.

**Cordinator의 모든 결정은 취소가 불가능하다.**

- Commit/Abort결정에 대해서 그 사이에 어떤 문제가 생기더라고, 어떤 방법을 써서라도 완료해야한다.
    - 트랜잭션의 정합성(일관성)


### 분신 시스템 환경에서 트랜잭션을 유지하기 위한 방안 - 보상 트랜잭션(Compensating Transaction)

- 일련의 작업을 보상(보정) 하기 위한 트랜잭션을 구현하기 위한 하나의 방법
- 고전적인 데이터베이스 개념에서 따옴
    - commit 된 데이터를 commit되기 이전의 상태로 변경하기위한 작업
    - 데이터베이스 개념상으로는 작업(do)하던 내용을 다시 Undo 할때 ‘보상’(Compensate)라는 용어를 사용

MSA 환경에서의 보상 트랜잭션이란?

DBMS 기준

- commit 된 데이터를 commit 되기 이전의 상태로 변경하기 위한 작업

MSA

- commit 된
    - **데이터 변경을 수반 하는 요청이 정상적으로 종료 된 서비스의**
- 데이터를
    - **API호출에 대해서**
- ‘commit’되기 이전의
    - **그 데이터 변경 요청을 하기 이전의**
- 상태로 변경하기 위한 작업
    - **상태로 되돌리기 위한 API**


**보상 트랜잭션의 한계**

- 보상 트랜잭션 요청에 지연 혹은 실패 문제가 새익는 경우, 보상 트랜잭션을 호출하는 주체는 명확한 판단이 어렵다.