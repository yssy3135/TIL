### MSA 전환 필요성, 가능여부 판단

- 개발, 배포시 다른 팀의 소스 혹은 공통 모듈 등으로 인한 일정 조율/커뮤니케이션이 방해될 정도인가?
- 느려지는 개발, 배포 과정으로 인해 필요한 비즈니스 개발이 지연된 적이 있나? (Business Capabilities)
- 단 건의 배포로 인한 전체적인 영향도 파악이 어렵고, 실제로 놓친부분으로 인해 장애가 빈번하게 발생하는가?
- 공통적으로 사용하는 모듈 수정시, 영향도 파악과 커뮤니케이션에 대한 부담이 압박으로 다가오나?
- 주요 서비스로 인한 빈번한 DB 부하로 인해, 타 서비스에서 영향을 받은 적이 빈번한가?

### 가능 여부 측면에 대한 진단

- 엔지니어링 조직에서 MSA 구조와 각 서비스의 통신에 대한 기본적인 아키텍처를 이해하고 있나?
- CI/CD 파이프라인을 위한 Devops/SRE 조직이 별도로 존재하고 트러블 슈팅을 위한 인프라 지식이 있나?
- 어려워진 트러블슈팅과 모니터링 난이도를 해결하기 위한 스택(EFK, Prometheus, Elastic Search, Grafana,..)들을 구축을 적절하게 할수 있는 상황인가?
- MSA/Cloud 환경에 대한 적절한 보안을 책임질 수 있는 보안 담당자가 존재하나?
- 사내 엔지니어링 최고 책임자가 MSA 전환에 대한 충분한 필요성을 느끼고 공감하나?

**MSA 전환을 위해서 풀어야 할 문제 식별 및 패턴**

### 분해, 통신, 트랜잭션 패턴

**분해패턴**

- MSA 소프트웨어 아키텍처를 설계함에 있어

  모놀리식 비즈니스 구조를 어떤 판단기준에 따라 서비스를 분리할 것인지에 대한 패턴

  즉 분해를 해결하기 위핸 패턴


모놀리식 → MSA 로 가면서 N개의 서비스로 분해되면서 어떻게 1개를 N로 나눌것인지?

**비즈니스 능력에 따른 분해 (Business Ability)**

- 복잡한 비즈니스 능력 을 기준으로 서비스를 분해

e.g 송금 서비스, 주문 서비스, …

**장점**

- 비즈니스가 복잡하고 , 대규모 조직의 경우
    - 비즈니스 → 하위 도메인 분해시 오히려 내부 서비스가 지나치게 생길 수 있다.
- 비즈니스 특성으로 인해 내부 서비스간 통신이 매우 빈번할 경우

**단점**

- 서비스간 응집도, 결합도, 종속성 증가
- 서비스 즉 도메인 별 팀의 구조가 희성될 가능성 from conway`s law
  (우리가 만들어둔 시스템의 구조에 따라서 비즈니스 팀의 구조가 따라간다)

**하위 도메인 패턴별 분해(Sub-Domain) from DDD**

- 복잡한 비즈니스 일지라도, 포함된 내부의 하위 도메인을 단위로 분리.

e.g 계좌 도메인, 내부 잔액 도메인, 뱅킹(외부 은행과 통신만 담당), …

**장점**

- 서비스 간 독립성, 격리성이 증가 / 결합도 감소
- 서비스 간 종속성 최소화, 서비스 간 영향도 감소
- 장애 영향도 최소화
- MSA 철학에 부합하는 패턴

**단점**

- 서비스간 불필요한 통신 가능성, 성능 이슈 (http, gRPC)
    - **상호간 많은 호출에 따른 트러블 슈팅이 어렵다**
- 지나치게 많은 서비스로 분리될 가능성
- 대규모 시스템에서는 비효율성 크게 증가 가능성

**어느것이 무조건맞다 어느것이 무조건 틀리다는 크게 의미가없다**

- 비즈니스 능력에 따른 분해로 시작해서 하위 도메인 패턴 분해가 될 수  있다.
- 하위 도메인 패턴 분해로 시작해서 비즈니스 능력에 따른 분해가 될 수 있다.

### 통신 패턴

MSA 설계를 통해 도출된 서비스간 어떤 방식으로 통신할지 결정하는 패턴

**Sync Pattern(동기 패턴)**

어떤 서비스가 다른 서비스로 특정 Request 이후 그 Response를 받을 때까지 멈춰있어도 되는 경우

- 멈춰있는 동안 스레드 낭비가 일어남

e.g HTTP(Restful), gRPC

**Async Pattern(비동기 패턴)**

어떤 서비스가 다른 서비스로 Request이후, 바로 Response 를 받지 않아도 되는 경우

e.g Kafka 등을 이용한 Message Queueing, Callback(Response가 오면 그때 수행), Polling(일정 주기마다 확인), …

### 트랜잭션 패턴

MSA 설계를 통해 도출된 서비스의 트랜잭션을 해결해 주기 위한 패턴

**2PC (2Phase Commit)**

- 트랜잭션의 완료를 2(N) 단계에 거쳐서 수행
- Commit Request → (작업 추가 수행) → (실패시 ) Rollback (성공시 ) Commit
- 2PC를 관리하는 cordinator가 존재 (성공 여부 판단), 관리해주어야 한다
    - cordinator가 요청을 받아 성공 여부를 판단해주어야 하는데 요청을 전달하는 과정에서 문제가 생길 가능성이 있다.

**Compensating Transactions (보상 트랜잭션)**

특정 요청과 요청이 정상이고 종료된 행동(트랜잭션)을 이전 상태로 되돌리기 위한 행동(트랜잭션)

**Saga Pattern(사가 패턴)**

- 2PC와 보상 트랜잭션의 장점을 살린 패턴
- 트랜잭션의 선, 후 관계를 사전에 정의하고 필요와 경우에 따라 Cordinator가 보상 트랜잭션을 이용, 관리하여 분산 시스템 환경에서 트랜잭션을 구현하기 위한 패턴

**누락처리 동기 비동기**

**동기**

- 실패하면 끝
- 이후 파이프라인을 태우기 어렵다

**비동기**

- 누락을 처리하기에 좋은 수단
- message queueing 등을 통해 비동기 이벤트를 쌓는다면 이벤트를 통해 주기적으로 확인하고 후속처리를 시도해볼 수 있다

### MSA 적용을 위한 패턴

**msa로 인해 요런 문제들이 발생했고 이것을 해결하기 위해 생겨난 패턴들**

### **데이터 쿼리 패턴**

- MSA 소프트웨어 아키텍처를 설계하면서 생긴 ‘데이터 쿼리’의 어려움을 해결하기 위한 패턴

**API Aggregation 패턴 (API 조합 패턴)**

- 필요한 데이터를 얻어오기 위해서, 분리된 서비스들 각각에 각 도메인에 대한 데이터를 요청 후 필요에 맞게 Aggregation
- e.g. 송금이 최종적으로 성공한 요청 건에 대해, 같이 실행된 외부 은행에 대한 계좌 요청들의 외부 API 호출 횟수

**CQRS 패턴 (커맨드와 쿼리를 분리하는 패턴)**

- Command(Write, Update, Delete) 작업과, Query(Read) 작업의 Endpoint를 분리하고
  Command에서 발생된 데이터의 변경을 이벤트 발행을 통해 원하는 포맷대로 Query를 위한 전용 데이터 구조를 만들어 이곳에서 복잡한 Query를 담당.
- Command를 위한 서비스와 Read를 위한 서비스를 별개로 구성
    - command 서비스가 변경이 될 때 event broker에  이벤트를 쌓음.
    - Read 서비스가  consume하여 DB에 이벤트를 쌓고 적절히 가공하여 사용하는 방식이 있음

### **가시성 (Visibility, Observability)**

- MSA 소프트웨어 아키텍처를 설계하면서 생긴 로깅, 모니터링의 어려움(가시성의 부재)를 해결하기 위한 패턴
- 로깅 및 메트릭의 중앙집중 및 필터링 들을 통한 한곳에서의 모니터링
- 하나의 트랜잭션에 대해 여러개의 각 서비스 요청들을 하나의 요청처럼 볼 수 있게 하는 트레이싱
- **구체적으로 어떻게 로깅, 메트릭을 저장하고 인덱싱하여 검색할 지에 집중하는 패턴**

로깅과 매트릭 차이

- 로깅
    - 트러블 슈팅이 목적
    - 누락이 되어서는 안됨
- 메트릭
    - 누락이 되어도 괜찮다
    - 메트릭의 목적은 어플리케이션, 서버의 지표를 시계열 저장( prometheus, influx) 시간에 따라 증감하는 수치를 보는것에 의의가 있다.

### **신뢰성 (Reliability)**

- MSA 소프트웨어 아키텍처를 설계하면서, 분리/분해로 인해 떨어진 신뢰성을 해결하기 위한 패턴
  장애 복구, 자가 치유, 무정지 배포 등을 구현하기 위한 패턴들이 이에 속한다

**서킷 브레이커 (Circuit Breaker)**

- 신뢰성을 높이기 위한 패턴의 일종으로, 분산 시스템에서 장애 전파를 막고 피해를 최소화 하기 위한 패턴
- 발동조건과 해제 조건이 존재한다(자가치유)

**무정지 배포**

- 완전히 동일한 의미는 아니지만 서버가 Graceful 하게 shutdown 되어야한다는 의미

### 테스트 패턴, 외부 API 패턴, 디스커버리 패턴

**테스트 패턴**

- 분리된 서비스들이 서로 빈번하게 호출되는 모놀리식과 다른 MSA 환경에서 여러 테스트 방식을 적용해서 ‘테스트’의 본질적인 의미를 해결하기 위한 패턴
- e.g. 단위 테스트, 통합 테스트, E2E 테스트(종단간 테스트)

**외부 API 패턴**

- 서비스 간 통신시 구현과 관련된 종속성을 해결하기 위한 패턴.
- 어떤 서비스가 다른 서비스를 호출할 때 직접 호출이 아닌 리버스 프록시 역할을 하는 인터페이스 서비스를 제공하여 마이크로서비스간 내부 구현방식과 무관하게 유연성을 가질 수 있는 패턴
    - 서비스 호출 시에는 ‘필요한 데이터’만, 실제 구현은 상황에 따라 유연하게?

**디스커버리 패턴**

- 수많은 컨테이너 서버들의 상태를 정상적으로 관리하기 어려웠던 문제를 해결하기 위한 패턴
- 수 많은 서비스들이 정상적으로 동작하는지를 판단하고, 상황에 따라 적절한 동작을 하는 메커니즘을 제공하는 패턴
- e.g. 쿠버네티스 Rediness Probe, Liveness Probe

**모놀리식 환경에서는 비교적 쉬운 방식으로 구현이 가능했던 것들이 MSA에서는 굉장히 Challenging 한 문제로 다가온다.**

- 이런 문제를 해결하기 위한 수단이자 도구이다.
- 문제를 정확히 이해와 파악하고 적절한 해결방법, 기술스택을 판단할 수 있는 준비가 되어있어야 한다.
- 모든 기술들을 항상 비판적으로 받아들여라…..지금 우리 상황에서 왜를 불어봐라, 바로 명확하게 대답할 수 있는 상황이 된다면 적용해라.