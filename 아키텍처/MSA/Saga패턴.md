### SAGA 패턴

- 이벤트 방식으로 트랜잭션에 포함된 여러작업(각 서비스의 API Call)의 결과를 게시하고 이벤트를 비동기 처리하여 다음 작업들을 진행

### SAGA 패턴의 종류

- Saga 패턴을 구현하는 방법에는 크게 2종류

**코레오크레피(Choreography)패턴**

- 독립적인 조율자(Orchestrator)를 두지 않고, Saga를 구현하는 방법
- 구현이 비교적 간단, 트랜잭션 상황을 모니터링하기 어렵다
    - 각각의 서비스는 정의된 작업만을 수행하게 된다.

**코레오그래피 패턴 적용시 주의점과 특징**

- 이벤트를 publish(Produce)하는 작업이, 내부 서비스의 트랜잭션과 하나로 묶여야 한다.
    - e.g. 작업은 실패했지만 이벤트는 발행
    - 그렇지 않으면 내부(각 서비스 로컬) 데이터 변경을 위한 작업 이후 정상적으로 이벤트가 발행되지 않을 수 있다. → 올바른 패턴 구현 불가
- 각 서비스의 입장에서는 구현이 단순하다. 복잡도가 낮다.
    - 각 서비스 입장에서는 사전에 정의된 이벤트만 받고, 정의된 이벤트만 보내면 되기 때문
        - 그러나, 복잡한 비즈니스가 될 수록 전체적인 트랜잭션의 상태나 Saga의 정의에 대한 분석과 유지보수가 어려워질 수 있다.



**오케스트레이션(Orchestration)패턴**

- 독립적인 조율자(Orchestrator)를 두어, 하나의 Saga(트랜잭션)에 대한 매니징을 담당하는 방법
- 구현이 비교적 어렵지만, 비교적 전체적인 트랜잭션의 모니터링이 수월하다
- saga의 정의를 한곳에서 가지고 있기 때문에 변경이나 관리가 쉽다.

**오케스트레이션 패턴 적용시 주의할 점과 특징**

- 추가적인 인프라(오케스트레이터)가 필요, 이를 관리하기 위한 대책이 동반되어야 한다.
- 각 서비스에서의 구현은 비교적 간단해지고 보상 트랜잭션만 구현하면 된다.
    - 관심사 분리 측면에서 유지보수 효율성이 올라간다.
- 트랜잭션에 대한 비즈니스 로직이 오케스트레이터에 포함될 가능성이 있다.
    - 절대로 일어나서는 안됨

**기본적으로 2개의 패턴 모두 보상 트랜잭션을 사용한다는 공통점이 있다.**