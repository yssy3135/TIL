### MSA 환경에서 소프트웨어 아키텍처가 중요한 이유

- MSA는 모놀리스로부터 분리/분해된 Micro Services 들의 모임이다.
- Micro Services들을 이루는 비즈니스/도메인은 경우에 따라, 시간이 지남에 따라 성격, 복잡도가 증가한다.
- 개별적인 Micro Service 내에서도 비즈니스적인 목적에 따라 별개의 기능, 효율을 중요시 해야하는 상황이 발생한다
- Micro Service를 이루는 소프트웨어 아키텍처에 따라, 각 Micro Service의 Business Capabilities 변화

### Micro Service Architecture는 광의의 소프트웨어 아키텍처

- 즉, 유연성, 확장성, 낮은 응집도/결합도 등 MSA의 특성이 Micro Service 안에서도 필요한 이유

**당장 요청에 대한 완료 응답을 필요는 없지만(Async), 높은 성능을 요구하는 작업**

- 대규모 Command 작업을 수행하는 Cron Job

당장 응답해야 하지만, 적은 성능을 요구하는 작업

- 일반적인 조회-Query 서비스

호출하던 외부 서비스의 스펙이 변경되는 경우

- Request/Response Params가 변경 되었고 영향도 없이 빠르게 적용이 필요한 경우
- 성능이 조정되어, 최적의 Connection Pool 갯수 혹은 timeout 수치가 변경되는 경우

**통신 방식이 변경되는 경우**

- Sync방식에서 Async 방식으로 변경되어 비동기 Callback 방식으로 같은 로직을 처리할 경우

**변경되었을때 얼마나 빨리 영향도 없이 Business Capability를 만족시킬수 있냐**

![MSA에서의 아키텍처_img_1.png](images%2FMSA%EC%97%90%EC%84%9C%EC%9D%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_img_1.png)

### 대표적인 2개의 아키텍처 - Layered & Hexagonal

**Layered Architecture(계층화 아키텍처)**

- 여러개의 계층으로 나누어 각 계층에서 하는 일을 한정시켜 계층별로 독립적으로 개발, 배포, 확장이 가능
- Presentation / Application / Domain / Infra Layer 등으로 이루어짐
- 각 계층 내에서는 코드 수정과 유지보수 등이 비교적 쉽다. 계층간 접근이 자유로움
    - 다른계층의 메서드 call 가능성 존재
    - 하위 계층으로 로직의 의존성은 존재하나, 접근은 상위 계층으로도 가능한 상황들이 발생

- 1DB로 인한 각 계층의 역할, 목적과 계층간 의존성 구분이 희미해질 수 있다.
    - 그러나, 각 계층 내에서는 비교적 유연한 대처 가능
- 처음 개발 이후, 큰비즈니스 로직의 변화가 존재하지 않는다면 오히려 안정적
- 비교적 자유로운 접근 방향성으로 인한 빠른 개발, 코드의 재사용 그리고 편한 테스팅 가능
    - 1DB의 장점으로 빠른 비즈니스 로직 개발 가능

**모놀리스 구조와 계층별로 구분된 일반적인 프로젝트 조직구조에 최적화**

**Hexagonal Architecture (헥사고날 아키텍처)**

- 각 계층에서 하던일들을 “내부와 외부”라는 개념으로 나누어 각각에 맞는 별도의 인터페이스 정의
- ‘내부’의 로직은 오직 ‘외부’ 인터페이스를 통해서만 접근 가능
- 모든 비즈니스 로직은, 오직 외부에서 내부 방향으로만 호출이 가능, 경계간 이동이 제한

- 각 계층에서 하던일들을 ‘내부와 외부’ 라는 개념으로 나누어 각가겡 맞는 별도의 인터페이스를 정의
    - 어댑터와 포트
- ‘내부’의 로직은 오직 ‘외부’ 통해서만 접근이 가능하다
    - 모든 외부 시스템과의 직접적인 상호작용은 ‘어댑터’의 역할
    - 각 서비스에서 비즈니스 로직에 맞게 정의된 인터페이스는 ‘포트’
    - 즉, 외부 서비스와의 상호작용(어댑터)는 비즈니스 로직과의 작업을 정의한 인터페이스(포트) 랑만 서로 통신

모든 비즈니스 로직은, 오직 외부에서 내부방향 / 내부에서 외부방향으로만 호출이 가능

- 인바운드 어댑터 → 인바운드 포트 → 비즈니스 로직
- 비즈니스 로직 → 아웃바운드 포트 → 아웃바운드 어댑터

**단방향으로만 통신이 가능하다의 의미**

인바운드 어댑터는 인바운드 포트로만 호출이 되어야하고

아웃바운트 포트는 아웃바운트 어댑터로만 호출이 되어야 한다

**어댑터**

- 서비스의 입장에서 이 서비스가 사용하는 외부 시스템과의 직접적인 구현 및 상호작용을 처리
- e.g.
    - 외부 시스템(UI) 으로붙 들어온 Request가 가장 처음 만나는 Controller는 ‘인바운드 어댑터’
    - 메시지 브로커(kafka)로 부터 Consume 하는 동작은 처리하는 로직 핸들러는 ‘인바운드 어댑터’
    - DB(Mysql,..)에 직접적으로 접근하여 다양한 작업(CRUD)를 처리하기 위한 DAO는 ‘아웃바운드 어댑터’

**포트**

- 비즈니스 로직 입장에서 어댑터와 통신하기 위한 동작을 정의한 인터페이스
- e.g.
    - Controller로 부터들어온 요청으로부터 특정 비즈니스 로직을 수행하기 위한 동작을 정의한 인터페이스
    - Consume한 메시지를 처리하기 위한 비즈니스 로직의 동작을 정의한 인터페이스 → ‘인바운드 포트’
    - 비즈니스 로직에서 DB접근을 위해서 정의한 Repository 인터페이스는 → ‘아웃바운트 포트

**결론**

- 어댑터를 통해 외부 서비스의 의존성을 분리 언제든 쉽게 교체하여 유연한 확장성 있는 대처를 하고
- 포트를 통해 내부 비즈니스 로직과 인터페이스를 분리하여 내부 로직의 구현은 인터페이스와 무관하게 개발 가능하도록!
- 목적은? 유연성과 확장성 → MSA와 궁합이 좋다
    - 어떻게 유연성과 확장성을 가질수 있나? → 어댑터와 포트를 통해
  
![MSA에서의 아키텍처_img_2.png](images%2FMSA%EC%97%90%EC%84%9C%EC%9D%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_img_2.png)

MSA = 다수의 Micro Service의 소프트웨어 아키텍처의 모음

MSA의 최대 목적인 Business Capabilities를 만족하기 위한 Key는 빠른 확장성과 유연성

MSA를 이루는 각 Micro Service도 높은 확장성과 유연성이 필수적

**Hexagonal Architecture는 MSA 환경에서 매우 적절한 Software Architecture!**